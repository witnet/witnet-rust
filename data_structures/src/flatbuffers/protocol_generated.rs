// automatically generated by the FlatBuffers compiler, do not modify


pub mod protocol {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum IpAddress {
  NONE = 0,
  Ipv4 = 1,
  Ipv6 = 2,

}

const ENUM_MIN_IP_ADDRESS: u8 = 0;
const ENUM_MAX_IP_ADDRESS: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for IpAddress {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for IpAddress {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const IpAddress;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const IpAddress;
    unsafe { *p }
  }
}

impl flatbuffers::Push for IpAddress {
    type Output = IpAddress;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<IpAddress>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_IP_ADDRESS:[IpAddress; 3] = [
  IpAddress::NONE,
  IpAddress::Ipv4,
  IpAddress::Ipv6
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_IP_ADDRESS:[&'static str; 3] = [
    "NONE",
    "Ipv4",
    "Ipv6"
];

pub fn enum_name_ip_address(e: IpAddress) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_IP_ADDRESS[index]
}

pub struct IpAddressUnionTableOffset {}
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum HashType {
  SHA256 = 0,

}

const ENUM_MIN_HASH_TYPE: u8 = 0;
const ENUM_MAX_HASH_TYPE: u8 = 0;

impl<'a> flatbuffers::Follow<'a> for HashType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for HashType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const HashType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const HashType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for HashType {
    type Output = HashType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<HashType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_HASH_TYPE:[HashType; 1] = [
  HashType::SHA256
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_HASH_TYPE:[&'static str; 1] = [
    "SHA256"
];

pub fn enum_name_hash_type(e: HashType) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_HASH_TYPE[index]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Signature {
  NONE = 0,
  Secp256k1Signature = 1,

}

const ENUM_MIN_SIGNATURE: u8 = 0;
const ENUM_MAX_SIGNATURE: u8 = 1;

impl<'a> flatbuffers::Follow<'a> for Signature {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Signature {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Signature;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Signature;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Signature {
    type Output = Signature;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Signature>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_SIGNATURE:[Signature; 2] = [
  Signature::NONE,
  Signature::Secp256k1Signature
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_SIGNATURE:[&'static str; 2] = [
    "NONE",
    "Secp256k1Signature"
];

pub fn enum_name_signature(e: Signature) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_SIGNATURE[index]
}

pub struct SignatureUnionTableOffset {}
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Command {
  NONE = 0,
  Version = 1,
  Verack = 2,
  GetPeers = 3,
  Peers = 4,
  Ping = 5,
  Pong = 6,
  Block = 7,
  InventoryAnnouncement = 8,
  InventoryRequest = 9,
  LastBeacon = 10,
  Transaction = 11,

}

const ENUM_MIN_COMMAND: u8 = 0;
const ENUM_MAX_COMMAND: u8 = 11;

impl<'a> flatbuffers::Follow<'a> for Command {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Command {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Command;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Command;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Command {
    type Output = Command;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Command>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_COMMAND:[Command; 12] = [
  Command::NONE,
  Command::Version,
  Command::Verack,
  Command::GetPeers,
  Command::Peers,
  Command::Ping,
  Command::Pong,
  Command::Block,
  Command::InventoryAnnouncement,
  Command::InventoryRequest,
  Command::LastBeacon,
  Command::Transaction
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_COMMAND:[&'static str; 12] = [
    "NONE",
    "Version",
    "Verack",
    "GetPeers",
    "Peers",
    "Ping",
    "Pong",
    "Block",
    "InventoryAnnouncement",
    "InventoryRequest",
    "LastBeacon",
    "Transaction"
];

pub fn enum_name_command(e: Command) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_COMMAND[index]
}

pub struct CommandUnionTableOffset {}
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum InventoryItemType {
  Error = 0,
  Tx = 1,
  Block = 2,
  DataRequest = 3,
  DataResult = 4,

}

const ENUM_MIN_INVENTORY_ITEM_TYPE: u8 = 0;
const ENUM_MAX_INVENTORY_ITEM_TYPE: u8 = 4;

impl<'a> flatbuffers::Follow<'a> for InventoryItemType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for InventoryItemType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const InventoryItemType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const InventoryItemType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for InventoryItemType {
    type Output = InventoryItemType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<InventoryItemType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_INVENTORY_ITEM_TYPE:[InventoryItemType; 5] = [
  InventoryItemType::Error,
  InventoryItemType::Tx,
  InventoryItemType::Block,
  InventoryItemType::DataRequest,
  InventoryItemType::DataResult
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_INVENTORY_ITEM_TYPE:[&'static str; 5] = [
    "Error",
    "Tx",
    "Block",
    "DataRequest",
    "DataResult"
];

pub fn enum_name_inventory_item_type(e: InventoryItemType) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_INVENTORY_ITEM_TYPE[index]
}

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum InputUnion {
  NONE = 0,
  CommitInput = 1,
  RevealInput = 2,
  DataRequestInput = 3,

}

const ENUM_MIN_INPUT_UNION: u8 = 0;
const ENUM_MAX_INPUT_UNION: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for InputUnion {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for InputUnion {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const InputUnion;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const InputUnion;
    unsafe { *p }
  }
}

impl flatbuffers::Push for InputUnion {
    type Output = InputUnion;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<InputUnion>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_INPUT_UNION:[InputUnion; 4] = [
  InputUnion::NONE,
  InputUnion::CommitInput,
  InputUnion::RevealInput,
  InputUnion::DataRequestInput
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_INPUT_UNION:[&'static str; 4] = [
    "NONE",
    "CommitInput",
    "RevealInput",
    "DataRequestInput"
];

pub fn enum_name_input_union(e: InputUnion) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_INPUT_UNION[index]
}

pub struct InputUnionUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum OutputUnion {
  NONE = 0,
  ValueTransferOutput = 1,
  DataRequestOutput = 2,
  CommitOutput = 3,
  RevealOutput = 4,
  ConsensusOutput = 5,

}

const ENUM_MIN_OUTPUT_UNION: u8 = 0;
const ENUM_MAX_OUTPUT_UNION: u8 = 5;

impl<'a> flatbuffers::Follow<'a> for OutputUnion {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for OutputUnion {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const OutputUnion;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const OutputUnion;
    unsafe { *p }
  }
}

impl flatbuffers::Push for OutputUnion {
    type Output = OutputUnion;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<OutputUnion>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_OUTPUT_UNION:[OutputUnion; 6] = [
  OutputUnion::NONE,
  OutputUnion::ValueTransferOutput,
  OutputUnion::DataRequestOutput,
  OutputUnion::CommitOutput,
  OutputUnion::RevealOutput,
  OutputUnion::ConsensusOutput
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_OUTPUT_UNION:[&'static str; 6] = [
    "NONE",
    "ValueTransferOutput",
    "DataRequestOutput",
    "CommitOutput",
    "RevealOutput",
    "ConsensusOutput"
];

pub fn enum_name_output_union(e: OutputUnion) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_OUTPUT_UNION[index]
}

pub struct OutputUnionUnionTableOffset {}
pub enum Ipv4Offset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Ipv4<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Ipv4<'a> {
    type Inner = Ipv4<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Ipv4<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Ipv4 {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Ipv4Args) -> flatbuffers::WIPOffset<Ipv4<'bldr>> {
      let mut builder = Ipv4Builder::new(_fbb);
      builder.add_ip(args.ip);
      builder.finish()
    }

    pub const VT_IP: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn ip(&self) -> u32 {
    self._tab.get::<u32>(Ipv4::VT_IP, Some(0)).unwrap()
  }
}

pub struct Ipv4Args {
    pub ip: u32,
}
impl<'a> Default for Ipv4Args {
    #[inline]
    fn default() -> Self {
        Ipv4Args {
            ip: 0,
        }
    }
}
pub struct Ipv4Builder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Ipv4Builder<'a, 'b> {
  #[inline]
  pub fn add_ip(&mut self, ip: u32) {
    self.fbb_.push_slot::<u32>(Ipv4::VT_IP, ip, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Ipv4Builder<'a, 'b> {
    let start = _fbb.start_table();
    Ipv4Builder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Ipv4<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum Ipv6Offset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Ipv6<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Ipv6<'a> {
    type Inner = Ipv6<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Ipv6<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Ipv6 {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Ipv6Args) -> flatbuffers::WIPOffset<Ipv6<'bldr>> {
      let mut builder = Ipv6Builder::new(_fbb);
      builder.add_ip3(args.ip3);
      builder.add_ip2(args.ip2);
      builder.add_ip1(args.ip1);
      builder.add_ip0(args.ip0);
      builder.finish()
    }

    pub const VT_IP0: flatbuffers::VOffsetT = 4;
    pub const VT_IP1: flatbuffers::VOffsetT = 6;
    pub const VT_IP2: flatbuffers::VOffsetT = 8;
    pub const VT_IP3: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn ip0(&self) -> u32 {
    self._tab.get::<u32>(Ipv6::VT_IP0, Some(0)).unwrap()
  }
  #[inline]
  pub fn ip1(&self) -> u32 {
    self._tab.get::<u32>(Ipv6::VT_IP1, Some(0)).unwrap()
  }
  #[inline]
  pub fn ip2(&self) -> u32 {
    self._tab.get::<u32>(Ipv6::VT_IP2, Some(0)).unwrap()
  }
  #[inline]
  pub fn ip3(&self) -> u32 {
    self._tab.get::<u32>(Ipv6::VT_IP3, Some(0)).unwrap()
  }
}

pub struct Ipv6Args {
    pub ip0: u32,
    pub ip1: u32,
    pub ip2: u32,
    pub ip3: u32,
}
impl<'a> Default for Ipv6Args {
    #[inline]
    fn default() -> Self {
        Ipv6Args {
            ip0: 0,
            ip1: 0,
            ip2: 0,
            ip3: 0,
        }
    }
}
pub struct Ipv6Builder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Ipv6Builder<'a, 'b> {
  #[inline]
  pub fn add_ip0(&mut self, ip0: u32) {
    self.fbb_.push_slot::<u32>(Ipv6::VT_IP0, ip0, 0);
  }
  #[inline]
  pub fn add_ip1(&mut self, ip1: u32) {
    self.fbb_.push_slot::<u32>(Ipv6::VT_IP1, ip1, 0);
  }
  #[inline]
  pub fn add_ip2(&mut self, ip2: u32) {
    self.fbb_.push_slot::<u32>(Ipv6::VT_IP2, ip2, 0);
  }
  #[inline]
  pub fn add_ip3(&mut self, ip3: u32) {
    self.fbb_.push_slot::<u32>(Ipv6::VT_IP3, ip3, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Ipv6Builder<'a, 'b> {
    let start = _fbb.start_table();
    Ipv6Builder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Ipv6<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum AddressOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Address<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Address<'a> {
    type Inner = Address<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Address<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Address {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AddressArgs) -> flatbuffers::WIPOffset<Address<'bldr>> {
      let mut builder = AddressBuilder::new(_fbb);
      if let Some(x) = args.ip { builder.add_ip(x); }
      builder.add_port(args.port);
      builder.add_ip_type(args.ip_type);
      builder.finish()
    }

    pub const VT_IP_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_IP: flatbuffers::VOffsetT = 6;
    pub const VT_PORT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn ip_type(&self) -> IpAddress {
    self._tab.get::<IpAddress>(Address::VT_IP_TYPE, Some(IpAddress::NONE)).unwrap()
  }
  #[inline]
  pub fn ip(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Address::VT_IP, None)
  }
  #[inline]
  pub fn port(&self) -> u16 {
    self._tab.get::<u16>(Address::VT_PORT, Some(0)).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn ip_as_ipv_4(&'a self) -> Option<Ipv4> {
    if self.ip_type() == IpAddress::Ipv4 {
      self.ip().map(|u| Ipv4::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn ip_as_ipv_6(&'a self) -> Option<Ipv6> {
    if self.ip_type() == IpAddress::Ipv6 {
      self.ip().map(|u| Ipv6::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct AddressArgs {
    pub ip_type: IpAddress,
    pub ip: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub port: u16,
}
impl<'a> Default for AddressArgs {
    #[inline]
    fn default() -> Self {
        AddressArgs {
            ip_type: IpAddress::NONE,
            ip: None,
            port: 0,
        }
    }
}
pub struct AddressBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AddressBuilder<'a, 'b> {
  #[inline]
  pub fn add_ip_type(&mut self, ip_type: IpAddress) {
    self.fbb_.push_slot::<IpAddress>(Address::VT_IP_TYPE, ip_type, IpAddress::NONE);
  }
  #[inline]
  pub fn add_ip(&mut self, ip: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Address::VT_IP, ip);
  }
  #[inline]
  pub fn add_port(&mut self, port: u16) {
    self.fbb_.push_slot::<u16>(Address::VT_PORT, port, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AddressBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AddressBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Address<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum HashOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Hash<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Hash<'a> {
    type Inner = Hash<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Hash<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Hash {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HashArgs<'args>) -> flatbuffers::WIPOffset<Hash<'bldr>> {
      let mut builder = HashBuilder::new(_fbb);
      if let Some(x) = args.bytes { builder.add_bytes(x); }
      builder.add_type_(args.type_);
      builder.finish()
    }

    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_BYTES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn type_(&self) -> HashType {
    self._tab.get::<HashType>(Hash::VT_TYPE_, Some(HashType::SHA256)).unwrap()
  }
  #[inline]
  pub fn bytes(&self) -> &'a [u8] {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Hash::VT_BYTES, None).map(|v| v.safe_slice()).unwrap()
  }
}

pub struct HashArgs<'a> {
    pub type_: HashType,
    pub bytes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for HashArgs<'a> {
    #[inline]
    fn default() -> Self {
        HashArgs {
            type_: HashType::SHA256,
            bytes: None, // required field
        }
    }
}
pub struct HashBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HashBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_(&mut self, type_: HashType) {
    self.fbb_.push_slot::<HashType>(Hash::VT_TYPE_, type_, HashType::SHA256);
  }
  #[inline]
  pub fn add_bytes(&mut self, bytes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hash::VT_BYTES, bytes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HashBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HashBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Hash<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Hash::VT_BYTES,"bytes");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum Secp256k1SignatureOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Secp256k1Signature<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Secp256k1Signature<'a> {
    type Inner = Secp256k1Signature<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Secp256k1Signature<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Secp256k1Signature {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Secp256k1SignatureArgs<'args>) -> flatbuffers::WIPOffset<Secp256k1Signature<'bldr>> {
      let mut builder = Secp256k1SignatureBuilder::new(_fbb);
      if let Some(x) = args.s { builder.add_s(x); }
      if let Some(x) = args.r { builder.add_r(x); }
      builder.finish()
    }

    pub const VT_R: flatbuffers::VOffsetT = 4;
    pub const VT_S: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn r(&self) -> &'a [u8] {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Secp256k1Signature::VT_R, None).map(|v| v.safe_slice()).unwrap()
  }
  #[inline]
  pub fn s(&self) -> &'a [u8] {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Secp256k1Signature::VT_S, None).map(|v| v.safe_slice()).unwrap()
  }
}

pub struct Secp256k1SignatureArgs<'a> {
    pub r: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub s: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for Secp256k1SignatureArgs<'a> {
    #[inline]
    fn default() -> Self {
        Secp256k1SignatureArgs {
            r: None, // required field
            s: None, // required field
        }
    }
}
pub struct Secp256k1SignatureBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Secp256k1SignatureBuilder<'a, 'b> {
  #[inline]
  pub fn add_r(&mut self, r: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Secp256k1Signature::VT_R, r);
  }
  #[inline]
  pub fn add_s(&mut self, s: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Secp256k1Signature::VT_S, s);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Secp256k1SignatureBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Secp256k1SignatureBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Secp256k1Signature<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Secp256k1Signature::VT_R,"r");
    self.fbb_.required(o, Secp256k1Signature::VT_S,"s");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum MessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Message<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Message<'a> {
    type Inner = Message<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Message<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Message {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MessageArgs) -> flatbuffers::WIPOffset<Message<'bldr>> {
      let mut builder = MessageBuilder::new(_fbb);
      if let Some(x) = args.command { builder.add_command(x); }
      builder.add_magic(args.magic);
      builder.add_command_type(args.command_type);
      builder.finish()
    }

    pub const VT_MAGIC: flatbuffers::VOffsetT = 4;
    pub const VT_COMMAND_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_COMMAND: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn magic(&self) -> u16 {
    self._tab.get::<u16>(Message::VT_MAGIC, Some(0)).unwrap()
  }
  #[inline]
  pub fn command_type(&self) -> Command {
    self._tab.get::<Command>(Message::VT_COMMAND_TYPE, Some(Command::NONE)).unwrap()
  }
  #[inline]
  pub fn command(&self) -> flatbuffers::Table<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Message::VT_COMMAND, None).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_version(&'a self) -> Option<Version> {
    if self.command_type() == Command::Version {
      Some(Version::init_from_table(self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_verack(&'a self) -> Option<Verack> {
    if self.command_type() == Command::Verack {
      Some(Verack::init_from_table(self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_get_peers(&'a self) -> Option<GetPeers> {
    if self.command_type() == Command::GetPeers {
      Some(GetPeers::init_from_table(self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_peers(&'a self) -> Option<Peers> {
    if self.command_type() == Command::Peers {
      Some(Peers::init_from_table(self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_ping(&'a self) -> Option<Ping> {
    if self.command_type() == Command::Ping {
      Some(Ping::init_from_table(self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_pong(&'a self) -> Option<Pong> {
    if self.command_type() == Command::Pong {
      Some(Pong::init_from_table(self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_block(&'a self) -> Option<Block> {
    if self.command_type() == Command::Block {
      Some(Block::init_from_table(self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_inventory_announcement(&'a self) -> Option<InventoryAnnouncement> {
    if self.command_type() == Command::InventoryAnnouncement {
      Some(InventoryAnnouncement::init_from_table(self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_inventory_request(&'a self) -> Option<InventoryRequest> {
    if self.command_type() == Command::InventoryRequest {
      Some(InventoryRequest::init_from_table(self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_last_beacon(&'a self) -> Option<LastBeacon> {
    if self.command_type() == Command::LastBeacon {
      Some(LastBeacon::init_from_table(self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_transaction(&'a self) -> Option<Transaction> {
    if self.command_type() == Command::Transaction {
      Some(Transaction::init_from_table(self.command()))
    } else {
      None
    }
  }

}

pub struct MessageArgs {
    pub magic: u16,
    pub command_type: Command,
    pub command: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for MessageArgs {
    #[inline]
    fn default() -> Self {
        MessageArgs {
            magic: 0,
            command_type: Command::NONE,
            command: None, // required field
        }
    }
}
pub struct MessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_magic(&mut self, magic: u16) {
    self.fbb_.push_slot::<u16>(Message::VT_MAGIC, magic, 0);
  }
  #[inline]
  pub fn add_command_type(&mut self, command_type: Command) {
    self.fbb_.push_slot::<Command>(Message::VT_COMMAND_TYPE, command_type, Command::NONE);
  }
  #[inline]
  pub fn add_command(&mut self, command: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_COMMAND, command);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Message::VT_COMMAND,"command");
    flatbuffers::WIPOffset::new(o.value())
  }
}

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
pub enum VersionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Version<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Version<'a> {
    type Inner = Version<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Version<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Version {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args VersionArgs<'args>) -> flatbuffers::WIPOffset<Version<'bldr>> {
      let mut builder = VersionBuilder::new(_fbb);
      builder.add_nonce(args.nonce);
      builder.add_genesis(args.genesis);
      builder.add_capabilities(args.capabilities);
      builder.add_timestamp(args.timestamp);
      builder.add_last_epoch(args.last_epoch);
      if let Some(x) = args.user_agent { builder.add_user_agent(x); }
      if let Some(x) = args.receiver_address { builder.add_receiver_address(x); }
      if let Some(x) = args.sender_address { builder.add_sender_address(x); }
      builder.add_version(args.version);
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 6;
    pub const VT_CAPABILITIES: flatbuffers::VOffsetT = 8;
    pub const VT_SENDER_ADDRESS: flatbuffers::VOffsetT = 10;
    pub const VT_RECEIVER_ADDRESS: flatbuffers::VOffsetT = 12;
    pub const VT_USER_AGENT: flatbuffers::VOffsetT = 14;
    pub const VT_LAST_EPOCH: flatbuffers::VOffsetT = 16;
    pub const VT_GENESIS: flatbuffers::VOffsetT = 18;
    pub const VT_NONCE: flatbuffers::VOffsetT = 20;

  #[inline]
  pub fn version(&self) -> u32 {
    self._tab.get::<u32>(Version::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn timestamp(&self) -> i64 {
    self._tab.get::<i64>(Version::VT_TIMESTAMP, Some(0)).unwrap()
  }
  #[inline]
  pub fn capabilities(&self) -> u64 {
    self._tab.get::<u64>(Version::VT_CAPABILITIES, Some(0)).unwrap()
  }
  #[inline]
  pub fn sender_address(&self) -> Option<Address<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Address<'a>>>(Version::VT_SENDER_ADDRESS, None)
  }
  #[inline]
  pub fn receiver_address(&self) -> Option<Address<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Address<'a>>>(Version::VT_RECEIVER_ADDRESS, None)
  }
  #[inline]
  pub fn user_agent(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Version::VT_USER_AGENT, None).unwrap()
  }
  #[inline]
  pub fn last_epoch(&self) -> u32 {
    self._tab.get::<u32>(Version::VT_LAST_EPOCH, Some(0)).unwrap()
  }
  #[inline]
  pub fn genesis(&self) -> u64 {
    self._tab.get::<u64>(Version::VT_GENESIS, Some(0)).unwrap()
  }
  #[inline]
  pub fn nonce(&self) -> u64 {
    self._tab.get::<u64>(Version::VT_NONCE, Some(0)).unwrap()
  }
}

pub struct VersionArgs<'a> {
    pub version: u32,
    pub timestamp: i64,
    pub capabilities: u64,
    pub sender_address: Option<flatbuffers::WIPOffset<Address<'a >>>,
    pub receiver_address: Option<flatbuffers::WIPOffset<Address<'a >>>,
    pub user_agent: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub last_epoch: u32,
    pub genesis: u64,
    pub nonce: u64,
}
impl<'a> Default for VersionArgs<'a> {
    #[inline]
    fn default() -> Self {
        VersionArgs {
            version: 0,
            timestamp: 0,
            capabilities: 0,
            sender_address: None,
            receiver_address: None,
            user_agent: None, // required field
            last_epoch: 0,
            genesis: 0,
            nonce: 0,
        }
    }
}
pub struct VersionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VersionBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(Version::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: i64) {
    self.fbb_.push_slot::<i64>(Version::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_capabilities(&mut self, capabilities: u64) {
    self.fbb_.push_slot::<u64>(Version::VT_CAPABILITIES, capabilities, 0);
  }
  #[inline]
  pub fn add_sender_address(&mut self, sender_address: flatbuffers::WIPOffset<Address<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Address>>(Version::VT_SENDER_ADDRESS, sender_address);
  }
  #[inline]
  pub fn add_receiver_address(&mut self, receiver_address: flatbuffers::WIPOffset<Address<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Address>>(Version::VT_RECEIVER_ADDRESS, receiver_address);
  }
  #[inline]
  pub fn add_user_agent(&mut self, user_agent: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Version::VT_USER_AGENT, user_agent);
  }
  #[inline]
  pub fn add_last_epoch(&mut self, last_epoch: u32) {
    self.fbb_.push_slot::<u32>(Version::VT_LAST_EPOCH, last_epoch, 0);
  }
  #[inline]
  pub fn add_genesis(&mut self, genesis: u64) {
    self.fbb_.push_slot::<u64>(Version::VT_GENESIS, genesis, 0);
  }
  #[inline]
  pub fn add_nonce(&mut self, nonce: u64) {
    self.fbb_.push_slot::<u64>(Version::VT_NONCE, nonce, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VersionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VersionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Version<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Version::VT_USER_AGENT,"user_agent");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum VerackOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Verack<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Verack<'a> {
    type Inner = Verack<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Verack<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Verack {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args VerackArgs) -> flatbuffers::WIPOffset<Verack<'bldr>> {
      let mut builder = VerackBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct VerackArgs {
}
impl<'a> Default for VerackArgs {
    #[inline]
    fn default() -> Self {
        VerackArgs {
        }
    }
}
pub struct VerackBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VerackBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VerackBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VerackBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Verack<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
pub enum GetPeersOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GetPeers<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetPeers<'a> {
    type Inner = GetPeers<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GetPeers<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GetPeers {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args GetPeersArgs) -> flatbuffers::WIPOffset<GetPeers<'bldr>> {
      let mut builder = GetPeersBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct GetPeersArgs {
}
impl<'a> Default for GetPeersArgs {
    #[inline]
    fn default() -> Self {
        GetPeersArgs {
        }
    }
}
pub struct GetPeersBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetPeersBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetPeersBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetPeersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetPeers<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PeersOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Peers<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Peers<'a> {
    type Inner = Peers<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Peers<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Peers {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PeersArgs<'args>) -> flatbuffers::WIPOffset<Peers<'bldr>> {
      let mut builder = PeersBuilder::new(_fbb);
      if let Some(x) = args.peers { builder.add_peers(x); }
      builder.finish()
    }

    pub const VT_PEERS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn peers(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Address<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Address<'a>>>>>(Peers::VT_PEERS, None)
  }
}

pub struct PeersArgs<'a> {
    pub peers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Address<'a >>>>>,
}
impl<'a> Default for PeersArgs<'a> {
    #[inline]
    fn default() -> Self {
        PeersArgs {
            peers: None,
        }
    }
}
pub struct PeersBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PeersBuilder<'a, 'b> {
  #[inline]
  pub fn add_peers(&mut self, peers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Address<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Peers::VT_PEERS, peers);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PeersBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PeersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Peers<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
pub enum PingOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Ping<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Ping<'a> {
    type Inner = Ping<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Ping<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Ping {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PingArgs) -> flatbuffers::WIPOffset<Ping<'bldr>> {
      let mut builder = PingBuilder::new(_fbb);
      builder.add_nonce(args.nonce);
      builder.finish()
    }

    pub const VT_NONCE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn nonce(&self) -> u64 {
    self._tab.get::<u64>(Ping::VT_NONCE, Some(0)).unwrap()
  }
}

pub struct PingArgs {
    pub nonce: u64,
}
impl<'a> Default for PingArgs {
    #[inline]
    fn default() -> Self {
        PingArgs {
            nonce: 0,
        }
    }
}
pub struct PingBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PingBuilder<'a, 'b> {
  #[inline]
  pub fn add_nonce(&mut self, nonce: u64) {
    self.fbb_.push_slot::<u64>(Ping::VT_NONCE, nonce, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PingBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Ping<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PongOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Pong<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Pong<'a> {
    type Inner = Pong<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Pong<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Pong {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PongArgs) -> flatbuffers::WIPOffset<Pong<'bldr>> {
      let mut builder = PongBuilder::new(_fbb);
      builder.add_nonce(args.nonce);
      builder.finish()
    }

    pub const VT_NONCE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn nonce(&self) -> u64 {
    self._tab.get::<u64>(Pong::VT_NONCE, Some(0)).unwrap()
  }
}

pub struct PongArgs {
    pub nonce: u64,
}
impl<'a> Default for PongArgs {
    #[inline]
    fn default() -> Self {
        PongArgs {
            nonce: 0,
        }
    }
}
pub struct PongBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PongBuilder<'a, 'b> {
  #[inline]
  pub fn add_nonce(&mut self, nonce: u64) {
    self.fbb_.push_slot::<u64>(Pong::VT_NONCE, nonce, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PongBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PongBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Pong<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum InventoryEntryOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InventoryEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InventoryEntry<'a> {
    type Inner = InventoryEntry<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InventoryEntry<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InventoryEntry {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InventoryEntryArgs<'args>) -> flatbuffers::WIPOffset<InventoryEntry<'bldr>> {
      let mut builder = InventoryEntryBuilder::new(_fbb);
      if let Some(x) = args.hash { builder.add_hash(x); }
      builder.add_type_(args.type_);
      builder.finish()
    }

    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_HASH: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn type_(&self) -> InventoryItemType {
    self._tab.get::<InventoryItemType>(InventoryEntry::VT_TYPE_, Some(InventoryItemType::Error)).unwrap()
  }
  #[inline]
  pub fn hash(&self) -> Hash<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Hash<'a>>>(InventoryEntry::VT_HASH, None).unwrap()
  }
}

pub struct InventoryEntryArgs<'a> {
    pub type_: InventoryItemType,
    pub hash: Option<flatbuffers::WIPOffset<Hash<'a >>>,
}
impl<'a> Default for InventoryEntryArgs<'a> {
    #[inline]
    fn default() -> Self {
        InventoryEntryArgs {
            type_: InventoryItemType::Error,
            hash: None, // required field
        }
    }
}
pub struct InventoryEntryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InventoryEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_(&mut self, type_: InventoryItemType) {
    self.fbb_.push_slot::<InventoryItemType>(InventoryEntry::VT_TYPE_, type_, InventoryItemType::Error);
  }
  #[inline]
  pub fn add_hash(&mut self, hash: flatbuffers::WIPOffset<Hash<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Hash>>(InventoryEntry::VT_HASH, hash);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InventoryEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InventoryEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InventoryEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, InventoryEntry::VT_HASH,"hash");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum InventoryAnnouncementOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InventoryAnnouncement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InventoryAnnouncement<'a> {
    type Inner = InventoryAnnouncement<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InventoryAnnouncement<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InventoryAnnouncement {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InventoryAnnouncementArgs<'args>) -> flatbuffers::WIPOffset<InventoryAnnouncement<'bldr>> {
      let mut builder = InventoryAnnouncementBuilder::new(_fbb);
      if let Some(x) = args.inventory { builder.add_inventory(x); }
      builder.finish()
    }

    pub const VT_INVENTORY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn inventory(&self) -> flatbuffers::Vector<flatbuffers::ForwardsUOffset<InventoryEntry<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<InventoryEntry<'a>>>>>(InventoryAnnouncement::VT_INVENTORY, None).unwrap()
  }
}

pub struct InventoryAnnouncementArgs<'a> {
    pub inventory: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<InventoryEntry<'a >>>>>,
}
impl<'a> Default for InventoryAnnouncementArgs<'a> {
    #[inline]
    fn default() -> Self {
        InventoryAnnouncementArgs {
            inventory: None, // required field
        }
    }
}
pub struct InventoryAnnouncementBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InventoryAnnouncementBuilder<'a, 'b> {
  #[inline]
  pub fn add_inventory(&mut self, inventory: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<InventoryEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InventoryAnnouncement::VT_INVENTORY, inventory);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InventoryAnnouncementBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InventoryAnnouncementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InventoryAnnouncement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, InventoryAnnouncement::VT_INVENTORY,"inventory");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum InventoryRequestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InventoryRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InventoryRequest<'a> {
    type Inner = InventoryRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InventoryRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InventoryRequest {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InventoryRequestArgs<'args>) -> flatbuffers::WIPOffset<InventoryRequest<'bldr>> {
      let mut builder = InventoryRequestBuilder::new(_fbb);
      if let Some(x) = args.inventory { builder.add_inventory(x); }
      builder.finish()
    }

    pub const VT_INVENTORY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn inventory(&self) -> flatbuffers::Vector<flatbuffers::ForwardsUOffset<InventoryEntry<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<InventoryEntry<'a>>>>>(InventoryRequest::VT_INVENTORY, None).unwrap()
  }
}

pub struct InventoryRequestArgs<'a> {
    pub inventory: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<InventoryEntry<'a >>>>>,
}
impl<'a> Default for InventoryRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        InventoryRequestArgs {
            inventory: None, // required field
        }
    }
}
pub struct InventoryRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InventoryRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_inventory(&mut self, inventory: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<InventoryEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InventoryRequest::VT_INVENTORY, inventory);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InventoryRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InventoryRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InventoryRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, InventoryRequest::VT_INVENTORY,"inventory");
    flatbuffers::WIPOffset::new(o.value())
  }
}

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
pub enum CheckpointBeaconOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CheckpointBeacon<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CheckpointBeacon<'a> {
    type Inner = CheckpointBeacon<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CheckpointBeacon<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CheckpointBeacon {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CheckpointBeaconArgs<'args>) -> flatbuffers::WIPOffset<CheckpointBeacon<'bldr>> {
      let mut builder = CheckpointBeaconBuilder::new(_fbb);
      if let Some(x) = args.hash_prev_block { builder.add_hash_prev_block(x); }
      builder.add_checkpoint(args.checkpoint);
      builder.finish()
    }

    pub const VT_CHECKPOINT: flatbuffers::VOffsetT = 4;
    pub const VT_HASH_PREV_BLOCK: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn checkpoint(&self) -> u32 {
    self._tab.get::<u32>(CheckpointBeacon::VT_CHECKPOINT, Some(0)).unwrap()
  }
  #[inline]
  pub fn hash_prev_block(&self) -> Hash<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Hash<'a>>>(CheckpointBeacon::VT_HASH_PREV_BLOCK, None).unwrap()
  }
}

pub struct CheckpointBeaconArgs<'a> {
    pub checkpoint: u32,
    pub hash_prev_block: Option<flatbuffers::WIPOffset<Hash<'a >>>,
}
impl<'a> Default for CheckpointBeaconArgs<'a> {
    #[inline]
    fn default() -> Self {
        CheckpointBeaconArgs {
            checkpoint: 0,
            hash_prev_block: None, // required field
        }
    }
}
pub struct CheckpointBeaconBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CheckpointBeaconBuilder<'a, 'b> {
  #[inline]
  pub fn add_checkpoint(&mut self, checkpoint: u32) {
    self.fbb_.push_slot::<u32>(CheckpointBeacon::VT_CHECKPOINT, checkpoint, 0);
  }
  #[inline]
  pub fn add_hash_prev_block(&mut self, hash_prev_block: flatbuffers::WIPOffset<Hash<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Hash>>(CheckpointBeacon::VT_HASH_PREV_BLOCK, hash_prev_block);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CheckpointBeaconBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CheckpointBeaconBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CheckpointBeacon<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CheckpointBeacon::VT_HASH_PREV_BLOCK,"hash_prev_block");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BlockHeaderOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BlockHeader<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockHeader<'a> {
    type Inner = BlockHeader<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BlockHeader<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BlockHeader {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BlockHeaderArgs<'args>) -> flatbuffers::WIPOffset<BlockHeader<'bldr>> {
      let mut builder = BlockHeaderBuilder::new(_fbb);
      if let Some(x) = args.hash_merkle_root { builder.add_hash_merkle_root(x); }
      if let Some(x) = args.beacon { builder.add_beacon(x); }
      builder.add_version(args.version);
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_BEACON: flatbuffers::VOffsetT = 6;
    pub const VT_HASH_MERKLE_ROOT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn version(&self) -> u32 {
    self._tab.get::<u32>(BlockHeader::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn beacon(&self) -> CheckpointBeacon<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<CheckpointBeacon<'a>>>(BlockHeader::VT_BEACON, None).unwrap()
  }
  #[inline]
  pub fn hash_merkle_root(&self) -> Hash<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Hash<'a>>>(BlockHeader::VT_HASH_MERKLE_ROOT, None).unwrap()
  }
}

pub struct BlockHeaderArgs<'a> {
    pub version: u32,
    pub beacon: Option<flatbuffers::WIPOffset<CheckpointBeacon<'a >>>,
    pub hash_merkle_root: Option<flatbuffers::WIPOffset<Hash<'a >>>,
}
impl<'a> Default for BlockHeaderArgs<'a> {
    #[inline]
    fn default() -> Self {
        BlockHeaderArgs {
            version: 0,
            beacon: None, // required field
            hash_merkle_root: None, // required field
        }
    }
}
pub struct BlockHeaderBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockHeaderBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(BlockHeader::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_beacon(&mut self, beacon: flatbuffers::WIPOffset<CheckpointBeacon<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CheckpointBeacon>>(BlockHeader::VT_BEACON, beacon);
  }
  #[inline]
  pub fn add_hash_merkle_root(&mut self, hash_merkle_root: flatbuffers::WIPOffset<Hash<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Hash>>(BlockHeader::VT_HASH_MERKLE_ROOT, hash_merkle_root);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockHeaderBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockHeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BlockHeader<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, BlockHeader::VT_BEACON,"beacon");
    self.fbb_.required(o, BlockHeader::VT_HASH_MERKLE_ROOT,"hash_merkle_root");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum LeadershipProofOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct LeadershipProof<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LeadershipProof<'a> {
    type Inner = LeadershipProof<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> LeadershipProof<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LeadershipProof {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args LeadershipProofArgs) -> flatbuffers::WIPOffset<LeadershipProof<'bldr>> {
      let mut builder = LeadershipProofBuilder::new(_fbb);
      builder.add_influence(args.influence);
      if let Some(x) = args.block_sig { builder.add_block_sig(x); }
      builder.add_block_sig_type(args.block_sig_type);
      builder.finish()
    }

    pub const VT_BLOCK_SIG_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_BLOCK_SIG: flatbuffers::VOffsetT = 6;
    pub const VT_INFLUENCE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn block_sig_type(&self) -> Signature {
    self._tab.get::<Signature>(LeadershipProof::VT_BLOCK_SIG_TYPE, Some(Signature::NONE)).unwrap()
  }
  #[inline]
  pub fn block_sig(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(LeadershipProof::VT_BLOCK_SIG, None)
  }
  #[inline]
  pub fn influence(&self) -> u64 {
    self._tab.get::<u64>(LeadershipProof::VT_INFLUENCE, Some(0)).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn block_sig_as_secp_256k_1signature(&'a self) -> Option<Secp256k1Signature> {
    if self.block_sig_type() == Signature::Secp256k1Signature {
      self.block_sig().map(|u| Secp256k1Signature::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct LeadershipProofArgs {
    pub block_sig_type: Signature,
    pub block_sig: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub influence: u64,
}
impl<'a> Default for LeadershipProofArgs {
    #[inline]
    fn default() -> Self {
        LeadershipProofArgs {
            block_sig_type: Signature::NONE,
            block_sig: None,
            influence: 0,
        }
    }
}
pub struct LeadershipProofBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LeadershipProofBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_sig_type(&mut self, block_sig_type: Signature) {
    self.fbb_.push_slot::<Signature>(LeadershipProof::VT_BLOCK_SIG_TYPE, block_sig_type, Signature::NONE);
  }
  #[inline]
  pub fn add_block_sig(&mut self, block_sig: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LeadershipProof::VT_BLOCK_SIG, block_sig);
  }
  #[inline]
  pub fn add_influence(&mut self, influence: u64) {
    self.fbb_.push_slot::<u64>(LeadershipProof::VT_INFLUENCE, influence, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LeadershipProofBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LeadershipProofBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LeadershipProof<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BlockOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Block<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Block<'a> {
    type Inner = Block<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Block<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Block {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BlockArgs<'args>) -> flatbuffers::WIPOffset<Block<'bldr>> {
      let mut builder = BlockBuilder::new(_fbb);
      if let Some(x) = args.txns { builder.add_txns(x); }
      if let Some(x) = args.proof { builder.add_proof(x); }
      if let Some(x) = args.block_header { builder.add_block_header(x); }
      builder.finish()
    }

    pub const VT_BLOCK_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_PROOF: flatbuffers::VOffsetT = 6;
    pub const VT_TXNS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn block_header(&self) -> BlockHeader<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<BlockHeader<'a>>>(Block::VT_BLOCK_HEADER, None).unwrap()
  }
  #[inline]
  pub fn proof(&self) -> LeadershipProof<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<LeadershipProof<'a>>>(Block::VT_PROOF, None).unwrap()
  }
  #[inline]
  pub fn txns(&self) -> flatbuffers::Vector<flatbuffers::ForwardsUOffset<Transaction<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Transaction<'a>>>>>(Block::VT_TXNS, None).unwrap()
  }
}

pub struct BlockArgs<'a> {
    pub block_header: Option<flatbuffers::WIPOffset<BlockHeader<'a >>>,
    pub proof: Option<flatbuffers::WIPOffset<LeadershipProof<'a >>>,
    pub txns: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Transaction<'a >>>>>,
}
impl<'a> Default for BlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        BlockArgs {
            block_header: None, // required field
            proof: None, // required field
            txns: None, // required field
        }
    }
}
pub struct BlockBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_header(&mut self, block_header: flatbuffers::WIPOffset<BlockHeader<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BlockHeader>>(Block::VT_BLOCK_HEADER, block_header);
  }
  #[inline]
  pub fn add_proof(&mut self, proof: flatbuffers::WIPOffset<LeadershipProof<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LeadershipProof>>(Block::VT_PROOF, proof);
  }
  #[inline]
  pub fn add_txns(&mut self, txns: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Transaction<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_TXNS, txns);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Block<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Block::VT_BLOCK_HEADER,"block_header");
    self.fbb_.required(o, Block::VT_PROOF,"proof");
    self.fbb_.required(o, Block::VT_TXNS,"txns");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RevealInputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RevealInput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RevealInput<'a> {
    type Inner = RevealInput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RevealInput<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RevealInput {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RevealInputArgs<'args>) -> flatbuffers::WIPOffset<RevealInput<'bldr>> {
      let mut builder = RevealInputBuilder::new(_fbb);
      builder.add_output_index(args.output_index);
      if let Some(x) = args.transaction_id { builder.add_transaction_id(x); }
      builder.finish()
    }

    pub const VT_TRANSACTION_ID: flatbuffers::VOffsetT = 4;
    pub const VT_OUTPUT_INDEX: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn transaction_id(&self) -> &'a [u8] {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RevealInput::VT_TRANSACTION_ID, None).map(|v| v.safe_slice()).unwrap()
  }
  #[inline]
  pub fn output_index(&self) -> u32 {
    self._tab.get::<u32>(RevealInput::VT_OUTPUT_INDEX, Some(0)).unwrap()
  }
}

pub struct RevealInputArgs<'a> {
    pub transaction_id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub output_index: u32,
}
impl<'a> Default for RevealInputArgs<'a> {
    #[inline]
    fn default() -> Self {
        RevealInputArgs {
            transaction_id: None, // required field
            output_index: 0,
        }
    }
}
pub struct RevealInputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RevealInputBuilder<'a, 'b> {
  #[inline]
  pub fn add_transaction_id(&mut self, transaction_id: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RevealInput::VT_TRANSACTION_ID, transaction_id);
  }
  #[inline]
  pub fn add_output_index(&mut self, output_index: u32) {
    self.fbb_.push_slot::<u32>(RevealInput::VT_OUTPUT_INDEX, output_index, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RevealInputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RevealInputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RevealInput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RevealInput::VT_TRANSACTION_ID,"transaction_id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DataRequestInputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct DataRequestInput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataRequestInput<'a> {
    type Inner = DataRequestInput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DataRequestInput<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DataRequestInput {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DataRequestInputArgs<'args>) -> flatbuffers::WIPOffset<DataRequestInput<'bldr>> {
      let mut builder = DataRequestInputBuilder::new(_fbb);
      if let Some(x) = args.poe { builder.add_poe(x); }
      builder.add_output_index(args.output_index);
      if let Some(x) = args.transaction_id { builder.add_transaction_id(x); }
      builder.finish()
    }

    pub const VT_TRANSACTION_ID: flatbuffers::VOffsetT = 4;
    pub const VT_OUTPUT_INDEX: flatbuffers::VOffsetT = 6;
    pub const VT_POE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn transaction_id(&self) -> &'a [u8] {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DataRequestInput::VT_TRANSACTION_ID, None).map(|v| v.safe_slice()).unwrap()
  }
  #[inline]
  pub fn output_index(&self) -> u32 {
    self._tab.get::<u32>(DataRequestInput::VT_OUTPUT_INDEX, Some(0)).unwrap()
  }
  #[inline]
  pub fn poe(&self) -> &'a [u8] {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DataRequestInput::VT_POE, None).map(|v| v.safe_slice()).unwrap()
  }
}

pub struct DataRequestInputArgs<'a> {
    pub transaction_id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub output_index: u32,
    pub poe: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for DataRequestInputArgs<'a> {
    #[inline]
    fn default() -> Self {
        DataRequestInputArgs {
            transaction_id: None, // required field
            output_index: 0,
            poe: None, // required field
        }
    }
}
pub struct DataRequestInputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DataRequestInputBuilder<'a, 'b> {
  #[inline]
  pub fn add_transaction_id(&mut self, transaction_id: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataRequestInput::VT_TRANSACTION_ID, transaction_id);
  }
  #[inline]
  pub fn add_output_index(&mut self, output_index: u32) {
    self.fbb_.push_slot::<u32>(DataRequestInput::VT_OUTPUT_INDEX, output_index, 0);
  }
  #[inline]
  pub fn add_poe(&mut self, poe: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataRequestInput::VT_POE, poe);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DataRequestInputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DataRequestInputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataRequestInput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DataRequestInput::VT_TRANSACTION_ID,"transaction_id");
    self.fbb_.required(o, DataRequestInput::VT_POE,"poe");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CommitInputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CommitInput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CommitInput<'a> {
    type Inner = CommitInput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CommitInput<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CommitInput {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CommitInputArgs<'args>) -> flatbuffers::WIPOffset<CommitInput<'bldr>> {
      let mut builder = CommitInputBuilder::new(_fbb);
      builder.add_nonce(args.nonce);
      if let Some(x) = args.reveal { builder.add_reveal(x); }
      builder.add_output_index(args.output_index);
      if let Some(x) = args.transaction_id { builder.add_transaction_id(x); }
      builder.finish()
    }

    pub const VT_TRANSACTION_ID: flatbuffers::VOffsetT = 4;
    pub const VT_OUTPUT_INDEX: flatbuffers::VOffsetT = 6;
    pub const VT_REVEAL: flatbuffers::VOffsetT = 8;
    pub const VT_NONCE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn transaction_id(&self) -> &'a [u8] {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CommitInput::VT_TRANSACTION_ID, None).map(|v| v.safe_slice()).unwrap()
  }
  #[inline]
  pub fn output_index(&self) -> u32 {
    self._tab.get::<u32>(CommitInput::VT_OUTPUT_INDEX, Some(0)).unwrap()
  }
  #[inline]
  pub fn reveal(&self) -> &'a [u8] {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CommitInput::VT_REVEAL, None).map(|v| v.safe_slice()).unwrap()
  }
  #[inline]
  pub fn nonce(&self) -> u64 {
    self._tab.get::<u64>(CommitInput::VT_NONCE, Some(0)).unwrap()
  }
}

pub struct CommitInputArgs<'a> {
    pub transaction_id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub output_index: u32,
    pub reveal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub nonce: u64,
}
impl<'a> Default for CommitInputArgs<'a> {
    #[inline]
    fn default() -> Self {
        CommitInputArgs {
            transaction_id: None, // required field
            output_index: 0,
            reveal: None, // required field
            nonce: 0,
        }
    }
}
pub struct CommitInputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CommitInputBuilder<'a, 'b> {
  #[inline]
  pub fn add_transaction_id(&mut self, transaction_id: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CommitInput::VT_TRANSACTION_ID, transaction_id);
  }
  #[inline]
  pub fn add_output_index(&mut self, output_index: u32) {
    self.fbb_.push_slot::<u32>(CommitInput::VT_OUTPUT_INDEX, output_index, 0);
  }
  #[inline]
  pub fn add_reveal(&mut self, reveal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CommitInput::VT_REVEAL, reveal);
  }
  #[inline]
  pub fn add_nonce(&mut self, nonce: u64) {
    self.fbb_.push_slot::<u64>(CommitInput::VT_NONCE, nonce, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CommitInputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CommitInputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CommitInput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CommitInput::VT_TRANSACTION_ID,"transaction_id");
    self.fbb_.required(o, CommitInput::VT_REVEAL,"reveal");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum InputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Input<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Input<'a> {
    type Inner = Input<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Input<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Input {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InputArgs) -> flatbuffers::WIPOffset<Input<'bldr>> {
      let mut builder = InputBuilder::new(_fbb);
      if let Some(x) = args.input { builder.add_input(x); }
      builder.add_input_type(args.input_type);
      builder.finish()
    }

    pub const VT_INPUT_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_INPUT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn input_type(&self) -> InputUnion {
    self._tab.get::<InputUnion>(Input::VT_INPUT_TYPE, Some(InputUnion::NONE)).unwrap()
  }
  #[inline]
  pub fn input(&self) -> flatbuffers::Table<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Input::VT_INPUT, None).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn input_as_commit_input(&'a self) -> Option<CommitInput> {
    if self.input_type() == InputUnion::CommitInput {
      Some(CommitInput::init_from_table(self.input()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn input_as_reveal_input(&'a self) -> Option<RevealInput> {
    if self.input_type() == InputUnion::RevealInput {
      Some(RevealInput::init_from_table(self.input()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn input_as_data_request_input(&'a self) -> Option<DataRequestInput> {
    if self.input_type() == InputUnion::DataRequestInput {
      Some(DataRequestInput::init_from_table(self.input()))
    } else {
      None
    }
  }

}

pub struct InputArgs {
    pub input_type: InputUnion,
    pub input: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for InputArgs {
    #[inline]
    fn default() -> Self {
        InputArgs {
            input_type: InputUnion::NONE,
            input: None, // required field
        }
    }
}
pub struct InputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InputBuilder<'a, 'b> {
  #[inline]
  pub fn add_input_type(&mut self, input_type: InputUnion) {
    self.fbb_.push_slot::<InputUnion>(Input::VT_INPUT_TYPE, input_type, InputUnion::NONE);
  }
  #[inline]
  pub fn add_input(&mut self, input: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Input::VT_INPUT, input);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Input<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Input::VT_INPUT,"input");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum OutputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Output<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Output<'a> {
    type Inner = Output<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Output<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Output {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OutputArgs) -> flatbuffers::WIPOffset<Output<'bldr>> {
      let mut builder = OutputBuilder::new(_fbb);
      if let Some(x) = args.output { builder.add_output(x); }
      builder.add_output_type(args.output_type);
      builder.finish()
    }

    pub const VT_OUTPUT_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_OUTPUT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn output_type(&self) -> OutputUnion {
    self._tab.get::<OutputUnion>(Output::VT_OUTPUT_TYPE, Some(OutputUnion::NONE)).unwrap()
  }
  #[inline]
  pub fn output(&self) -> flatbuffers::Table<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Output::VT_OUTPUT, None).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn output_as_value_transfer_output(&'a self) -> Option<ValueTransferOutput> {
    if self.output_type() == OutputUnion::ValueTransferOutput {
      Some(ValueTransferOutput::init_from_table(self.output()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn output_as_data_request_output(&'a self) -> Option<DataRequestOutput> {
    if self.output_type() == OutputUnion::DataRequestOutput {
      Some(DataRequestOutput::init_from_table(self.output()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn output_as_commit_output(&'a self) -> Option<CommitOutput> {
    if self.output_type() == OutputUnion::CommitOutput {
      Some(CommitOutput::init_from_table(self.output()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn output_as_reveal_output(&'a self) -> Option<RevealOutput> {
    if self.output_type() == OutputUnion::RevealOutput {
      Some(RevealOutput::init_from_table(self.output()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn output_as_consensus_output(&'a self) -> Option<ConsensusOutput> {
    if self.output_type() == OutputUnion::ConsensusOutput {
      Some(ConsensusOutput::init_from_table(self.output()))
    } else {
      None
    }
  }

}

pub struct OutputArgs {
    pub output_type: OutputUnion,
    pub output: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for OutputArgs {
    #[inline]
    fn default() -> Self {
        OutputArgs {
            output_type: OutputUnion::NONE,
            output: None, // required field
        }
    }
}
pub struct OutputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OutputBuilder<'a, 'b> {
  #[inline]
  pub fn add_output_type(&mut self, output_type: OutputUnion) {
    self.fbb_.push_slot::<OutputUnion>(Output::VT_OUTPUT_TYPE, output_type, OutputUnion::NONE);
  }
  #[inline]
  pub fn add_output(&mut self, output: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Output::VT_OUTPUT, output);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OutputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OutputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Output<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Output::VT_OUTPUT,"output");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ValueTransferOutputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ValueTransferOutput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ValueTransferOutput<'a> {
    type Inner = ValueTransferOutput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ValueTransferOutput<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ValueTransferOutput {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ValueTransferOutputArgs<'args>) -> flatbuffers::WIPOffset<ValueTransferOutput<'bldr>> {
      let mut builder = ValueTransferOutputBuilder::new(_fbb);
      builder.add_value(args.value);
      if let Some(x) = args.pkh { builder.add_pkh(x); }
      builder.finish()
    }

    pub const VT_PKH: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn pkh(&self) -> Hash<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Hash<'a>>>(ValueTransferOutput::VT_PKH, None).unwrap()
  }
  #[inline]
  pub fn value(&self) -> u64 {
    self._tab.get::<u64>(ValueTransferOutput::VT_VALUE, Some(0)).unwrap()
  }
}

pub struct ValueTransferOutputArgs<'a> {
    pub pkh: Option<flatbuffers::WIPOffset<Hash<'a >>>,
    pub value: u64,
}
impl<'a> Default for ValueTransferOutputArgs<'a> {
    #[inline]
    fn default() -> Self {
        ValueTransferOutputArgs {
            pkh: None, // required field
            value: 0,
        }
    }
}
pub struct ValueTransferOutputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ValueTransferOutputBuilder<'a, 'b> {
  #[inline]
  pub fn add_pkh(&mut self, pkh: flatbuffers::WIPOffset<Hash<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Hash>>(ValueTransferOutput::VT_PKH, pkh);
  }
  #[inline]
  pub fn add_value(&mut self, value: u64) {
    self.fbb_.push_slot::<u64>(ValueTransferOutput::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ValueTransferOutputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ValueTransferOutputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ValueTransferOutput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ValueTransferOutput::VT_PKH,"pkh");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DataRequestOutputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct DataRequestOutput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataRequestOutput<'a> {
    type Inner = DataRequestOutput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DataRequestOutput<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DataRequestOutput {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DataRequestOutputArgs<'args>) -> flatbuffers::WIPOffset<DataRequestOutput<'bldr>> {
      let mut builder = DataRequestOutputBuilder::new(_fbb);
      builder.add_time_lock(args.time_lock);
      builder.add_tally_fee(args.tally_fee);
      builder.add_reveal_fee(args.reveal_fee);
      builder.add_commit_fee(args.commit_fee);
      builder.add_value(args.value);
      if let Some(x) = args.data_request { builder.add_data_request(x); }
      builder.add_backup_witnesses(args.backup_witnesses);
      builder.add_witnesses(args.witnesses);
      builder.finish()
    }

    pub const VT_DATA_REQUEST: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;
    pub const VT_WITNESSES: flatbuffers::VOffsetT = 8;
    pub const VT_BACKUP_WITNESSES: flatbuffers::VOffsetT = 10;
    pub const VT_COMMIT_FEE: flatbuffers::VOffsetT = 12;
    pub const VT_REVEAL_FEE: flatbuffers::VOffsetT = 14;
    pub const VT_TALLY_FEE: flatbuffers::VOffsetT = 16;
    pub const VT_TIME_LOCK: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn data_request(&self) -> &'a [u8] {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DataRequestOutput::VT_DATA_REQUEST, None).map(|v| v.safe_slice()).unwrap()
  }
  #[inline]
  pub fn value(&self) -> u64 {
    self._tab.get::<u64>(DataRequestOutput::VT_VALUE, Some(0)).unwrap()
  }
  #[inline]
  pub fn witnesses(&self) -> u8 {
    self._tab.get::<u8>(DataRequestOutput::VT_WITNESSES, Some(0)).unwrap()
  }
  #[inline]
  pub fn backup_witnesses(&self) -> u8 {
    self._tab.get::<u8>(DataRequestOutput::VT_BACKUP_WITNESSES, Some(0)).unwrap()
  }
  #[inline]
  pub fn commit_fee(&self) -> u64 {
    self._tab.get::<u64>(DataRequestOutput::VT_COMMIT_FEE, Some(0)).unwrap()
  }
  #[inline]
  pub fn reveal_fee(&self) -> u64 {
    self._tab.get::<u64>(DataRequestOutput::VT_REVEAL_FEE, Some(0)).unwrap()
  }
  #[inline]
  pub fn tally_fee(&self) -> u64 {
    self._tab.get::<u64>(DataRequestOutput::VT_TALLY_FEE, Some(0)).unwrap()
  }
  #[inline]
  pub fn time_lock(&self) -> u64 {
    self._tab.get::<u64>(DataRequestOutput::VT_TIME_LOCK, Some(0)).unwrap()
  }
}

pub struct DataRequestOutputArgs<'a> {
    pub data_request: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub value: u64,
    pub witnesses: u8,
    pub backup_witnesses: u8,
    pub commit_fee: u64,
    pub reveal_fee: u64,
    pub tally_fee: u64,
    pub time_lock: u64,
}
impl<'a> Default for DataRequestOutputArgs<'a> {
    #[inline]
    fn default() -> Self {
        DataRequestOutputArgs {
            data_request: None, // required field
            value: 0,
            witnesses: 0,
            backup_witnesses: 0,
            commit_fee: 0,
            reveal_fee: 0,
            tally_fee: 0,
            time_lock: 0,
        }
    }
}
pub struct DataRequestOutputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DataRequestOutputBuilder<'a, 'b> {
  #[inline]
  pub fn add_data_request(&mut self, data_request: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DataRequestOutput::VT_DATA_REQUEST, data_request);
  }
  #[inline]
  pub fn add_value(&mut self, value: u64) {
    self.fbb_.push_slot::<u64>(DataRequestOutput::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn add_witnesses(&mut self, witnesses: u8) {
    self.fbb_.push_slot::<u8>(DataRequestOutput::VT_WITNESSES, witnesses, 0);
  }
  #[inline]
  pub fn add_backup_witnesses(&mut self, backup_witnesses: u8) {
    self.fbb_.push_slot::<u8>(DataRequestOutput::VT_BACKUP_WITNESSES, backup_witnesses, 0);
  }
  #[inline]
  pub fn add_commit_fee(&mut self, commit_fee: u64) {
    self.fbb_.push_slot::<u64>(DataRequestOutput::VT_COMMIT_FEE, commit_fee, 0);
  }
  #[inline]
  pub fn add_reveal_fee(&mut self, reveal_fee: u64) {
    self.fbb_.push_slot::<u64>(DataRequestOutput::VT_REVEAL_FEE, reveal_fee, 0);
  }
  #[inline]
  pub fn add_tally_fee(&mut self, tally_fee: u64) {
    self.fbb_.push_slot::<u64>(DataRequestOutput::VT_TALLY_FEE, tally_fee, 0);
  }
  #[inline]
  pub fn add_time_lock(&mut self, time_lock: u64) {
    self.fbb_.push_slot::<u64>(DataRequestOutput::VT_TIME_LOCK, time_lock, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DataRequestOutputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DataRequestOutputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DataRequestOutput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DataRequestOutput::VT_DATA_REQUEST,"data_request");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CommitOutputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CommitOutput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CommitOutput<'a> {
    type Inner = CommitOutput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CommitOutput<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CommitOutput {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CommitOutputArgs<'args>) -> flatbuffers::WIPOffset<CommitOutput<'bldr>> {
      let mut builder = CommitOutputBuilder::new(_fbb);
      builder.add_value(args.value);
      if let Some(x) = args.commitment { builder.add_commitment(x); }
      builder.finish()
    }

    pub const VT_COMMITMENT: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn commitment(&self) -> Hash<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Hash<'a>>>(CommitOutput::VT_COMMITMENT, None).unwrap()
  }
  #[inline]
  pub fn value(&self) -> u64 {
    self._tab.get::<u64>(CommitOutput::VT_VALUE, Some(0)).unwrap()
  }
}

pub struct CommitOutputArgs<'a> {
    pub commitment: Option<flatbuffers::WIPOffset<Hash<'a >>>,
    pub value: u64,
}
impl<'a> Default for CommitOutputArgs<'a> {
    #[inline]
    fn default() -> Self {
        CommitOutputArgs {
            commitment: None, // required field
            value: 0,
        }
    }
}
pub struct CommitOutputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CommitOutputBuilder<'a, 'b> {
  #[inline]
  pub fn add_commitment(&mut self, commitment: flatbuffers::WIPOffset<Hash<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Hash>>(CommitOutput::VT_COMMITMENT, commitment);
  }
  #[inline]
  pub fn add_value(&mut self, value: u64) {
    self.fbb_.push_slot::<u64>(CommitOutput::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CommitOutputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CommitOutputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CommitOutput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CommitOutput::VT_COMMITMENT,"commitment");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RevealOutputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RevealOutput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RevealOutput<'a> {
    type Inner = RevealOutput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RevealOutput<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RevealOutput {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RevealOutputArgs<'args>) -> flatbuffers::WIPOffset<RevealOutput<'bldr>> {
      let mut builder = RevealOutputBuilder::new(_fbb);
      builder.add_value(args.value);
      if let Some(x) = args.pkh { builder.add_pkh(x); }
      if let Some(x) = args.reveal { builder.add_reveal(x); }
      builder.finish()
    }

    pub const VT_REVEAL: flatbuffers::VOffsetT = 4;
    pub const VT_PKH: flatbuffers::VOffsetT = 6;
    pub const VT_VALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn reveal(&self) -> &'a [u8] {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(RevealOutput::VT_REVEAL, None).map(|v| v.safe_slice()).unwrap()
  }
  #[inline]
  pub fn pkh(&self) -> Hash<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Hash<'a>>>(RevealOutput::VT_PKH, None).unwrap()
  }
  #[inline]
  pub fn value(&self) -> u64 {
    self._tab.get::<u64>(RevealOutput::VT_VALUE, Some(0)).unwrap()
  }
}

pub struct RevealOutputArgs<'a> {
    pub reveal: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub pkh: Option<flatbuffers::WIPOffset<Hash<'a >>>,
    pub value: u64,
}
impl<'a> Default for RevealOutputArgs<'a> {
    #[inline]
    fn default() -> Self {
        RevealOutputArgs {
            reveal: None, // required field
            pkh: None, // required field
            value: 0,
        }
    }
}
pub struct RevealOutputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RevealOutputBuilder<'a, 'b> {
  #[inline]
  pub fn add_reveal(&mut self, reveal: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RevealOutput::VT_REVEAL, reveal);
  }
  #[inline]
  pub fn add_pkh(&mut self, pkh: flatbuffers::WIPOffset<Hash<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Hash>>(RevealOutput::VT_PKH, pkh);
  }
  #[inline]
  pub fn add_value(&mut self, value: u64) {
    self.fbb_.push_slot::<u64>(RevealOutput::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RevealOutputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RevealOutputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RevealOutput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RevealOutput::VT_REVEAL,"reveal");
    self.fbb_.required(o, RevealOutput::VT_PKH,"pkh");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ConsensusOutputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ConsensusOutput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConsensusOutput<'a> {
    type Inner = ConsensusOutput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ConsensusOutput<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConsensusOutput {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConsensusOutputArgs<'args>) -> flatbuffers::WIPOffset<ConsensusOutput<'bldr>> {
      let mut builder = ConsensusOutputBuilder::new(_fbb);
      builder.add_value(args.value);
      if let Some(x) = args.pkh { builder.add_pkh(x); }
      if let Some(x) = args.result { builder.add_result(x); }
      builder.finish()
    }

    pub const VT_RESULT: flatbuffers::VOffsetT = 4;
    pub const VT_PKH: flatbuffers::VOffsetT = 6;
    pub const VT_VALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn result(&self) -> &'a [u8] {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ConsensusOutput::VT_RESULT, None).map(|v| v.safe_slice()).unwrap()
  }
  #[inline]
  pub fn pkh(&self) -> Hash<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Hash<'a>>>(ConsensusOutput::VT_PKH, None).unwrap()
  }
  #[inline]
  pub fn value(&self) -> u64 {
    self._tab.get::<u64>(ConsensusOutput::VT_VALUE, Some(0)).unwrap()
  }
}

pub struct ConsensusOutputArgs<'a> {
    pub result: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub pkh: Option<flatbuffers::WIPOffset<Hash<'a >>>,
    pub value: u64,
}
impl<'a> Default for ConsensusOutputArgs<'a> {
    #[inline]
    fn default() -> Self {
        ConsensusOutputArgs {
            result: None, // required field
            pkh: None, // required field
            value: 0,
        }
    }
}
pub struct ConsensusOutputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConsensusOutputBuilder<'a, 'b> {
  #[inline]
  pub fn add_result(&mut self, result: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConsensusOutput::VT_RESULT, result);
  }
  #[inline]
  pub fn add_pkh(&mut self, pkh: flatbuffers::WIPOffset<Hash<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Hash>>(ConsensusOutput::VT_PKH, pkh);
  }
  #[inline]
  pub fn add_value(&mut self, value: u64) {
    self.fbb_.push_slot::<u64>(ConsensusOutput::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConsensusOutputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConsensusOutputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConsensusOutput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ConsensusOutput::VT_RESULT,"result");
    self.fbb_.required(o, ConsensusOutput::VT_PKH,"pkh");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum KeyedSignatureOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct KeyedSignature<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KeyedSignature<'a> {
    type Inner = KeyedSignature<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> KeyedSignature<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        KeyedSignature {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args KeyedSignatureArgs<'args>) -> flatbuffers::WIPOffset<KeyedSignature<'bldr>> {
      let mut builder = KeyedSignatureBuilder::new(_fbb);
      if let Some(x) = args.public_key { builder.add_public_key(x); }
      if let Some(x) = args.signature { builder.add_signature(x); }
      builder.add_signature_type(args.signature_type);
      builder.finish()
    }

    pub const VT_SIGNATURE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_SIGNATURE: flatbuffers::VOffsetT = 6;
    pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn signature_type(&self) -> Signature {
    self._tab.get::<Signature>(KeyedSignature::VT_SIGNATURE_TYPE, Some(Signature::NONE)).unwrap()
  }
  #[inline]
  pub fn signature(&self) -> flatbuffers::Table<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(KeyedSignature::VT_SIGNATURE, None).unwrap()
  }
  #[inline]
  pub fn public_key(&self) -> &'a [u8] {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(KeyedSignature::VT_PUBLIC_KEY, None).map(|v| v.safe_slice()).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn signature_as_secp_256k_1signature(&'a self) -> Option<Secp256k1Signature> {
    if self.signature_type() == Signature::Secp256k1Signature {
      Some(Secp256k1Signature::init_from_table(self.signature()))
    } else {
      None
    }
  }

}

pub struct KeyedSignatureArgs<'a> {
    pub signature_type: Signature,
    pub signature: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub public_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for KeyedSignatureArgs<'a> {
    #[inline]
    fn default() -> Self {
        KeyedSignatureArgs {
            signature_type: Signature::NONE,
            signature: None, // required field
            public_key: None, // required field
        }
    }
}
pub struct KeyedSignatureBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> KeyedSignatureBuilder<'a, 'b> {
  #[inline]
  pub fn add_signature_type(&mut self, signature_type: Signature) {
    self.fbb_.push_slot::<Signature>(KeyedSignature::VT_SIGNATURE_TYPE, signature_type, Signature::NONE);
  }
  #[inline]
  pub fn add_signature(&mut self, signature: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyedSignature::VT_SIGNATURE, signature);
  }
  #[inline]
  pub fn add_public_key(&mut self, public_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyedSignature::VT_PUBLIC_KEY, public_key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> KeyedSignatureBuilder<'a, 'b> {
    let start = _fbb.start_table();
    KeyedSignatureBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KeyedSignature<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, KeyedSignature::VT_SIGNATURE,"signature");
    self.fbb_.required(o, KeyedSignature::VT_PUBLIC_KEY,"public_key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TransactionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Transaction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Transaction<'a> {
    type Inner = Transaction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Transaction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Transaction {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TransactionArgs<'args>) -> flatbuffers::WIPOffset<Transaction<'bldr>> {
      let mut builder = TransactionBuilder::new(_fbb);
      if let Some(x) = args.signatures { builder.add_signatures(x); }
      if let Some(x) = args.outputs { builder.add_outputs(x); }
      if let Some(x) = args.inputs { builder.add_inputs(x); }
      builder.add_version(args.version);
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_INPUTS: flatbuffers::VOffsetT = 6;
    pub const VT_OUTPUTS: flatbuffers::VOffsetT = 8;
    pub const VT_SIGNATURES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn version(&self) -> u32 {
    self._tab.get::<u32>(Transaction::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn inputs(&self) -> flatbuffers::Vector<flatbuffers::ForwardsUOffset<Input<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Input<'a>>>>>(Transaction::VT_INPUTS, None).unwrap()
  }
  #[inline]
  pub fn outputs(&self) -> flatbuffers::Vector<flatbuffers::ForwardsUOffset<Output<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Output<'a>>>>>(Transaction::VT_OUTPUTS, None).unwrap()
  }
  #[inline]
  pub fn signatures(&self) -> flatbuffers::Vector<flatbuffers::ForwardsUOffset<KeyedSignature<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<KeyedSignature<'a>>>>>(Transaction::VT_SIGNATURES, None).unwrap()
  }
}

pub struct TransactionArgs<'a> {
    pub version: u32,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Input<'a >>>>>,
    pub outputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Output<'a >>>>>,
    pub signatures: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<KeyedSignature<'a >>>>>,
}
impl<'a> Default for TransactionArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransactionArgs {
            version: 0,
            inputs: None, // required field
            outputs: None, // required field
            signatures: None, // required field
        }
    }
}
pub struct TransactionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransactionBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(Transaction::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Input<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn add_outputs(&mut self, outputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Output<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_OUTPUTS, outputs);
  }
  #[inline]
  pub fn add_signatures(&mut self, signatures: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyedSignature<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_SIGNATURES, signatures);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransactionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TransactionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Transaction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Transaction::VT_INPUTS,"inputs");
    self.fbb_.required(o, Transaction::VT_OUTPUTS,"outputs");
    self.fbb_.required(o, Transaction::VT_SIGNATURES,"signatures");
    flatbuffers::WIPOffset::new(o.value())
  }
}

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
pub enum LastBeaconOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct LastBeacon<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LastBeacon<'a> {
    type Inner = LastBeacon<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> LastBeacon<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LastBeacon {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args LastBeaconArgs<'args>) -> flatbuffers::WIPOffset<LastBeacon<'bldr>> {
      let mut builder = LastBeaconBuilder::new(_fbb);
      if let Some(x) = args.highest_block_checkpoint { builder.add_highest_block_checkpoint(x); }
      builder.finish()
    }

    pub const VT_HIGHEST_BLOCK_CHECKPOINT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn highest_block_checkpoint(&self) -> CheckpointBeacon<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<CheckpointBeacon<'a>>>(LastBeacon::VT_HIGHEST_BLOCK_CHECKPOINT, None).unwrap()
  }
}

pub struct LastBeaconArgs<'a> {
    pub highest_block_checkpoint: Option<flatbuffers::WIPOffset<CheckpointBeacon<'a >>>,
}
impl<'a> Default for LastBeaconArgs<'a> {
    #[inline]
    fn default() -> Self {
        LastBeaconArgs {
            highest_block_checkpoint: None, // required field
        }
    }
}
pub struct LastBeaconBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LastBeaconBuilder<'a, 'b> {
  #[inline]
  pub fn add_highest_block_checkpoint(&mut self, highest_block_checkpoint: flatbuffers::WIPOffset<CheckpointBeacon<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CheckpointBeacon>>(LastBeacon::VT_HIGHEST_BLOCK_CHECKPOINT, highest_block_checkpoint);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LastBeaconBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LastBeaconBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LastBeacon<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, LastBeacon::VT_HIGHEST_BLOCK_CHECKPOINT,"highest_block_checkpoint");
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_message<'a>(buf: &'a [u8]) -> Message<'a> {
  flatbuffers::get_root::<Message<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_message<'a>(buf: &'a [u8]) -> Message<'a> {
  flatbuffers::get_size_prefixed_root::<Message<'a>>(buf)
}

#[inline]
pub fn finish_message_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_message_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Protocol

