// automatically generated by the FlatBuffers compiler, do not modify


pub mod protocol {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Command {
  NONE = 0,
  Version = 1,
  Verack = 2,
  GetPeers = 3,
  Peers = 4,
  Ping = 5,
  Pong = 6,
  Block = 7,
  Inv = 8,
  GetData = 9,

}

const ENUM_MIN_COMMAND: u8 = 0;
const ENUM_MAX_COMMAND: u8 = 9;

impl<'a> flatbuffers::Follow<'a> for Command {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Command {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Command;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Command;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Command {
    type Output = Command;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Command>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_COMMAND:[Command; 10] = [
  Command::NONE,
  Command::Version,
  Command::Verack,
  Command::GetPeers,
  Command::Peers,
  Command::Ping,
  Command::Pong,
  Command::Block,
  Command::Inv,
  Command::GetData
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_COMMAND:[&'static str; 10] = [
    "NONE",
    "Version",
    "Verack",
    "GetPeers",
    "Peers",
    "Ping",
    "Pong",
    "Block",
    "Inv",
    "GetData"
];

pub fn enum_name_command(e: Command) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_COMMAND[index]
}

pub struct CommandUnionTableOffset {}
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum IpAddress {
  NONE = 0,
  Ipv4 = 1,
  Ipv6 = 2,

}

const ENUM_MIN_IP_ADDRESS: u8 = 0;
const ENUM_MAX_IP_ADDRESS: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for IpAddress {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for IpAddress {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const IpAddress;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const IpAddress;
    unsafe { *p }
  }
}

impl flatbuffers::Push for IpAddress {
    type Output = IpAddress;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<IpAddress>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_IP_ADDRESS:[IpAddress; 3] = [
  IpAddress::NONE,
  IpAddress::Ipv4,
  IpAddress::Ipv6
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_IP_ADDRESS:[&'static str; 3] = [
    "NONE",
    "Ipv4",
    "Ipv6"
];

pub fn enum_name_ip_address(e: IpAddress) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_IP_ADDRESS[index]
}

pub struct IpAddressUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum HashType {
  SHA256 = 0,

}

const ENUM_MIN_HASH_TYPE: u8 = 0;
const ENUM_MAX_HASH_TYPE: u8 = 0;

impl<'a> flatbuffers::Follow<'a> for HashType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for HashType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const HashType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const HashType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for HashType {
    type Output = HashType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<HashType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_HASH_TYPE:[HashType; 1] = [
  HashType::SHA256
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_HASH_TYPE:[&'static str; 1] = [
    "SHA256"
];

pub fn enum_name_hash_type(e: HashType) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_HASH_TYPE[index]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum InvVectorType {
  Error = 0,
  Tx = 1,
  Block = 2,
  DataRequest = 3,
  DataResult = 4,

}

const ENUM_MIN_INV_VECTOR_TYPE: u8 = 0;
const ENUM_MAX_INV_VECTOR_TYPE: u8 = 4;

impl<'a> flatbuffers::Follow<'a> for InvVectorType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for InvVectorType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const InvVectorType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const InvVectorType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for InvVectorType {
    type Output = InvVectorType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<InvVectorType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_INV_VECTOR_TYPE:[InvVectorType; 5] = [
  InvVectorType::Error,
  InvVectorType::Tx,
  InvVectorType::Block,
  InvVectorType::DataRequest,
  InvVectorType::DataResult
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_INV_VECTOR_TYPE:[&'static str; 5] = [
    "Error",
    "Tx",
    "Block",
    "DataRequest",
    "DataResult"
];

pub fn enum_name_inv_vector_type(e: InvVectorType) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_INV_VECTOR_TYPE[index]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Signature {
  NONE = 0,
  Secp256k1Signature = 1,

}

const ENUM_MIN_SIGNATURE: u8 = 0;
const ENUM_MAX_SIGNATURE: u8 = 1;

impl<'a> flatbuffers::Follow<'a> for Signature {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Signature {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Signature;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Signature;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Signature {
    type Output = Signature;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Signature>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_SIGNATURE:[Signature; 2] = [
  Signature::NONE,
  Signature::Secp256k1Signature
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_SIGNATURE:[&'static str; 2] = [
    "NONE",
    "Secp256k1Signature"
];

pub fn enum_name_signature(e: Signature) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_SIGNATURE[index]
}

pub struct SignatureUnionTableOffset {}
pub enum MessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Message<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Message<'a> {
    type Inner = Message<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Message<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Message {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MessageArgs) -> flatbuffers::WIPOffset<Message<'bldr>> {
      let mut builder = MessageBuilder::new(_fbb);
      if let Some(x) = args.command { builder.add_command(x); }
      builder.add_magic(args.magic);
      builder.add_command_type(args.command_type);
      builder.finish()
    }

    pub const VT_MAGIC: flatbuffers::VOffsetT = 4;
    pub const VT_COMMAND_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_COMMAND: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn magic(&self) -> u16 {
    self._tab.get::<u16>(Message::VT_MAGIC, Some(0)).unwrap()
  }
  #[inline]
  pub fn command_type(&self) -> Command {
    self._tab.get::<Command>(Message::VT_COMMAND_TYPE, Some(Command::NONE)).unwrap()
  }
  #[inline]
  pub fn command(&self) -> flatbuffers::Table<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Message::VT_COMMAND, None).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_version(&'a self) -> Option<Version> {
    if self.command_type() == Command::Version {
      Some(Version::init_from_table(self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_verack(&'a self) -> Option<Verack> {
    if self.command_type() == Command::Verack {
      Some(Verack::init_from_table(self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_get_peers(&'a self) -> Option<GetPeers> {
    if self.command_type() == Command::GetPeers {
      Some(GetPeers::init_from_table(self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_peers(&'a self) -> Option<Peers> {
    if self.command_type() == Command::Peers {
      Some(Peers::init_from_table(self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_ping(&'a self) -> Option<Ping> {
    if self.command_type() == Command::Ping {
      Some(Ping::init_from_table(self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_pong(&'a self) -> Option<Pong> {
    if self.command_type() == Command::Pong {
      Some(Pong::init_from_table(self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_block(&'a self) -> Option<Block> {
    if self.command_type() == Command::Block {
      Some(Block::init_from_table(self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_inv(&'a self) -> Option<Inv> {
    if self.command_type() == Command::Inv {
      Some(Inv::init_from_table(self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_get_data(&'a self) -> Option<GetData> {
    if self.command_type() == Command::GetData {
      Some(GetData::init_from_table(self.command()))
    } else {
      None
    }
  }

}

pub struct MessageArgs {
    pub magic: u16,
    pub command_type: Command,
    pub command: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for MessageArgs {
    #[inline]
    fn default() -> Self {
        MessageArgs {
            magic: 0,
            command_type: Command::NONE,
            command: None, // required field
        }
    }
}
pub struct MessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_magic(&mut self, magic: u16) {
    self.fbb_.push_slot::<u16>(Message::VT_MAGIC, magic, 0);
  }
  #[inline]
  pub fn add_command_type(&mut self, command_type: Command) {
    self.fbb_.push_slot::<Command>(Message::VT_COMMAND_TYPE, command_type, Command::NONE);
  }
  #[inline]
  pub fn add_command(&mut self, command: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_COMMAND, command);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Message::VT_COMMAND,"command");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum Ipv4Offset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Ipv4<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Ipv4<'a> {
    type Inner = Ipv4<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Ipv4<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Ipv4 {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Ipv4Args) -> flatbuffers::WIPOffset<Ipv4<'bldr>> {
      let mut builder = Ipv4Builder::new(_fbb);
      builder.add_ip(args.ip);
      builder.finish()
    }

    pub const VT_IP: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn ip(&self) -> u32 {
    self._tab.get::<u32>(Ipv4::VT_IP, Some(0)).unwrap()
  }
}

pub struct Ipv4Args {
    pub ip: u32,
}
impl<'a> Default for Ipv4Args {
    #[inline]
    fn default() -> Self {
        Ipv4Args {
            ip: 0,
        }
    }
}
pub struct Ipv4Builder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Ipv4Builder<'a, 'b> {
  #[inline]
  pub fn add_ip(&mut self, ip: u32) {
    self.fbb_.push_slot::<u32>(Ipv4::VT_IP, ip, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Ipv4Builder<'a, 'b> {
    let start = _fbb.start_table();
    Ipv4Builder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Ipv4<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum Ipv6Offset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Ipv6<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Ipv6<'a> {
    type Inner = Ipv6<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Ipv6<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Ipv6 {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Ipv6Args) -> flatbuffers::WIPOffset<Ipv6<'bldr>> {
      let mut builder = Ipv6Builder::new(_fbb);
      builder.add_ip3(args.ip3);
      builder.add_ip2(args.ip2);
      builder.add_ip1(args.ip1);
      builder.add_ip0(args.ip0);
      builder.finish()
    }

    pub const VT_IP0: flatbuffers::VOffsetT = 4;
    pub const VT_IP1: flatbuffers::VOffsetT = 6;
    pub const VT_IP2: flatbuffers::VOffsetT = 8;
    pub const VT_IP3: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn ip0(&self) -> u32 {
    self._tab.get::<u32>(Ipv6::VT_IP0, Some(0)).unwrap()
  }
  #[inline]
  pub fn ip1(&self) -> u32 {
    self._tab.get::<u32>(Ipv6::VT_IP1, Some(0)).unwrap()
  }
  #[inline]
  pub fn ip2(&self) -> u32 {
    self._tab.get::<u32>(Ipv6::VT_IP2, Some(0)).unwrap()
  }
  #[inline]
  pub fn ip3(&self) -> u32 {
    self._tab.get::<u32>(Ipv6::VT_IP3, Some(0)).unwrap()
  }
}

pub struct Ipv6Args {
    pub ip0: u32,
    pub ip1: u32,
    pub ip2: u32,
    pub ip3: u32,
}
impl<'a> Default for Ipv6Args {
    #[inline]
    fn default() -> Self {
        Ipv6Args {
            ip0: 0,
            ip1: 0,
            ip2: 0,
            ip3: 0,
        }
    }
}
pub struct Ipv6Builder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Ipv6Builder<'a, 'b> {
  #[inline]
  pub fn add_ip0(&mut self, ip0: u32) {
    self.fbb_.push_slot::<u32>(Ipv6::VT_IP0, ip0, 0);
  }
  #[inline]
  pub fn add_ip1(&mut self, ip1: u32) {
    self.fbb_.push_slot::<u32>(Ipv6::VT_IP1, ip1, 0);
  }
  #[inline]
  pub fn add_ip2(&mut self, ip2: u32) {
    self.fbb_.push_slot::<u32>(Ipv6::VT_IP2, ip2, 0);
  }
  #[inline]
  pub fn add_ip3(&mut self, ip3: u32) {
    self.fbb_.push_slot::<u32>(Ipv6::VT_IP3, ip3, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Ipv6Builder<'a, 'b> {
    let start = _fbb.start_table();
    Ipv6Builder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Ipv6<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum AddressOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Address<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Address<'a> {
    type Inner = Address<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Address<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Address {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AddressArgs) -> flatbuffers::WIPOffset<Address<'bldr>> {
      let mut builder = AddressBuilder::new(_fbb);
      if let Some(x) = args.ip { builder.add_ip(x); }
      builder.add_port(args.port);
      builder.add_ip_type(args.ip_type);
      builder.finish()
    }

    pub const VT_IP_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_IP: flatbuffers::VOffsetT = 6;
    pub const VT_PORT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn ip_type(&self) -> IpAddress {
    self._tab.get::<IpAddress>(Address::VT_IP_TYPE, Some(IpAddress::NONE)).unwrap()
  }
  #[inline]
  pub fn ip(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Address::VT_IP, None)
  }
  #[inline]
  pub fn port(&self) -> u16 {
    self._tab.get::<u16>(Address::VT_PORT, Some(0)).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn ip_as_ipv_4(&'a self) -> Option<Ipv4> {
    if self.ip_type() == IpAddress::Ipv4 {
      self.ip().map(|u| Ipv4::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn ip_as_ipv_6(&'a self) -> Option<Ipv6> {
    if self.ip_type() == IpAddress::Ipv6 {
      self.ip().map(|u| Ipv6::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct AddressArgs {
    pub ip_type: IpAddress,
    pub ip: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub port: u16,
}
impl<'a> Default for AddressArgs {
    #[inline]
    fn default() -> Self {
        AddressArgs {
            ip_type: IpAddress::NONE,
            ip: None,
            port: 0,
        }
    }
}
pub struct AddressBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AddressBuilder<'a, 'b> {
  #[inline]
  pub fn add_ip_type(&mut self, ip_type: IpAddress) {
    self.fbb_.push_slot::<IpAddress>(Address::VT_IP_TYPE, ip_type, IpAddress::NONE);
  }
  #[inline]
  pub fn add_ip(&mut self, ip: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Address::VT_IP, ip);
  }
  #[inline]
  pub fn add_port(&mut self, port: u16) {
    self.fbb_.push_slot::<u16>(Address::VT_PORT, port, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AddressBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AddressBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Address<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum HashOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Hash<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Hash<'a> {
    type Inner = Hash<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Hash<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Hash {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HashArgs<'args>) -> flatbuffers::WIPOffset<Hash<'bldr>> {
      let mut builder = HashBuilder::new(_fbb);
      if let Some(x) = args.bytes { builder.add_bytes(x); }
      builder.add_type_(args.type_);
      builder.finish()
    }

    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_BYTES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn type_(&self) -> HashType {
    self._tab.get::<HashType>(Hash::VT_TYPE_, Some(HashType::SHA256)).unwrap()
  }
  #[inline]
  pub fn bytes(&self) -> &'a [u8] {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Hash::VT_BYTES, None).map(|v| v.safe_slice()).unwrap()
  }
}

pub struct HashArgs<'a> {
    pub type_: HashType,
    pub bytes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for HashArgs<'a> {
    #[inline]
    fn default() -> Self {
        HashArgs {
            type_: HashType::SHA256,
            bytes: None, // required field
        }
    }
}
pub struct HashBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HashBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_(&mut self, type_: HashType) {
    self.fbb_.push_slot::<HashType>(Hash::VT_TYPE_, type_, HashType::SHA256);
  }
  #[inline]
  pub fn add_bytes(&mut self, bytes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Hash::VT_BYTES, bytes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HashBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HashBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Hash<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Hash::VT_BYTES,"bytes");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum InvVectorOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InvVector<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InvVector<'a> {
    type Inner = InvVector<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InvVector<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InvVector {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InvVectorArgs<'args>) -> flatbuffers::WIPOffset<InvVector<'bldr>> {
      let mut builder = InvVectorBuilder::new(_fbb);
      if let Some(x) = args.hash { builder.add_hash(x); }
      builder.add_type_(args.type_);
      builder.finish()
    }

    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_HASH: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn type_(&self) -> InvVectorType {
    self._tab.get::<InvVectorType>(InvVector::VT_TYPE_, Some(InvVectorType::Error)).unwrap()
  }
  #[inline]
  pub fn hash(&self) -> Hash<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Hash<'a>>>(InvVector::VT_HASH, None).unwrap()
  }
}

pub struct InvVectorArgs<'a> {
    pub type_: InvVectorType,
    pub hash: Option<flatbuffers::WIPOffset<Hash<'a >>>,
}
impl<'a> Default for InvVectorArgs<'a> {
    #[inline]
    fn default() -> Self {
        InvVectorArgs {
            type_: InvVectorType::Error,
            hash: None, // required field
        }
    }
}
pub struct InvVectorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InvVectorBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_(&mut self, type_: InvVectorType) {
    self.fbb_.push_slot::<InvVectorType>(InvVector::VT_TYPE_, type_, InvVectorType::Error);
  }
  #[inline]
  pub fn add_hash(&mut self, hash: flatbuffers::WIPOffset<Hash<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Hash>>(InvVector::VT_HASH, hash);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InvVectorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InvVectorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InvVector<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, InvVector::VT_HASH,"hash");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum Secp256k1SignatureOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Secp256k1Signature<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Secp256k1Signature<'a> {
    type Inner = Secp256k1Signature<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Secp256k1Signature<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Secp256k1Signature {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Secp256k1SignatureArgs<'args>) -> flatbuffers::WIPOffset<Secp256k1Signature<'bldr>> {
      let mut builder = Secp256k1SignatureBuilder::new(_fbb);
      if let Some(x) = args.s { builder.add_s(x); }
      if let Some(x) = args.r { builder.add_r(x); }
      builder.finish()
    }

    pub const VT_R: flatbuffers::VOffsetT = 4;
    pub const VT_S: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn r(&self) -> &'a [u8] {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Secp256k1Signature::VT_R, None).map(|v| v.safe_slice()).unwrap()
  }
  #[inline]
  pub fn s(&self) -> &'a [u8] {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Secp256k1Signature::VT_S, None).map(|v| v.safe_slice()).unwrap()
  }
}

pub struct Secp256k1SignatureArgs<'a> {
    pub r: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub s: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for Secp256k1SignatureArgs<'a> {
    #[inline]
    fn default() -> Self {
        Secp256k1SignatureArgs {
            r: None, // required field
            s: None, // required field
        }
    }
}
pub struct Secp256k1SignatureBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Secp256k1SignatureBuilder<'a, 'b> {
  #[inline]
  pub fn add_r(&mut self, r: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Secp256k1Signature::VT_R, r);
  }
  #[inline]
  pub fn add_s(&mut self, s: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Secp256k1Signature::VT_S, s);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Secp256k1SignatureBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Secp256k1SignatureBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Secp256k1Signature<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Secp256k1Signature::VT_R,"r");
    self.fbb_.required(o, Secp256k1Signature::VT_S,"s");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum LeadershipProofOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct LeadershipProof<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LeadershipProof<'a> {
    type Inner = LeadershipProof<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> LeadershipProof<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LeadershipProof {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args LeadershipProofArgs) -> flatbuffers::WIPOffset<LeadershipProof<'bldr>> {
      let mut builder = LeadershipProofBuilder::new(_fbb);
      builder.add_influence(args.influence);
      if let Some(x) = args.block_sig { builder.add_block_sig(x); }
      builder.add_block_sig_type(args.block_sig_type);
      builder.finish()
    }

    pub const VT_BLOCK_SIG_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_BLOCK_SIG: flatbuffers::VOffsetT = 6;
    pub const VT_INFLUENCE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn block_sig_type(&self) -> Signature {
    self._tab.get::<Signature>(LeadershipProof::VT_BLOCK_SIG_TYPE, Some(Signature::NONE)).unwrap()
  }
  #[inline]
  pub fn block_sig(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(LeadershipProof::VT_BLOCK_SIG, None)
  }
  #[inline]
  pub fn influence(&self) -> u64 {
    self._tab.get::<u64>(LeadershipProof::VT_INFLUENCE, Some(0)).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn block_sig_as_secp_256k_1signature(&'a self) -> Option<Secp256k1Signature> {
    if self.block_sig_type() == Signature::Secp256k1Signature {
      self.block_sig().map(|u| Secp256k1Signature::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct LeadershipProofArgs {
    pub block_sig_type: Signature,
    pub block_sig: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub influence: u64,
}
impl<'a> Default for LeadershipProofArgs {
    #[inline]
    fn default() -> Self {
        LeadershipProofArgs {
            block_sig_type: Signature::NONE,
            block_sig: None,
            influence: 0,
        }
    }
}
pub struct LeadershipProofBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LeadershipProofBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_sig_type(&mut self, block_sig_type: Signature) {
    self.fbb_.push_slot::<Signature>(LeadershipProof::VT_BLOCK_SIG_TYPE, block_sig_type, Signature::NONE);
  }
  #[inline]
  pub fn add_block_sig(&mut self, block_sig: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LeadershipProof::VT_BLOCK_SIG, block_sig);
  }
  #[inline]
  pub fn add_influence(&mut self, influence: u64) {
    self.fbb_.push_slot::<u64>(LeadershipProof::VT_INFLUENCE, influence, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LeadershipProofBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LeadershipProofBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LeadershipProof<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CheckpointBeaconOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CheckpointBeacon<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CheckpointBeacon<'a> {
    type Inner = CheckpointBeacon<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CheckpointBeacon<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CheckpointBeacon {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CheckpointBeaconArgs<'args>) -> flatbuffers::WIPOffset<CheckpointBeacon<'bldr>> {
      let mut builder = CheckpointBeaconBuilder::new(_fbb);
      if let Some(x) = args.hash_prev_block { builder.add_hash_prev_block(x); }
      builder.add_checkpoint(args.checkpoint);
      builder.finish()
    }

    pub const VT_CHECKPOINT: flatbuffers::VOffsetT = 4;
    pub const VT_HASH_PREV_BLOCK: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn checkpoint(&self) -> u32 {
    self._tab.get::<u32>(CheckpointBeacon::VT_CHECKPOINT, Some(0)).unwrap()
  }
  #[inline]
  pub fn hash_prev_block(&self) -> Hash<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Hash<'a>>>(CheckpointBeacon::VT_HASH_PREV_BLOCK, None).unwrap()
  }
}

pub struct CheckpointBeaconArgs<'a> {
    pub checkpoint: u32,
    pub hash_prev_block: Option<flatbuffers::WIPOffset<Hash<'a >>>,
}
impl<'a> Default for CheckpointBeaconArgs<'a> {
    #[inline]
    fn default() -> Self {
        CheckpointBeaconArgs {
            checkpoint: 0,
            hash_prev_block: None, // required field
        }
    }
}
pub struct CheckpointBeaconBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CheckpointBeaconBuilder<'a, 'b> {
  #[inline]
  pub fn add_checkpoint(&mut self, checkpoint: u32) {
    self.fbb_.push_slot::<u32>(CheckpointBeacon::VT_CHECKPOINT, checkpoint, 0);
  }
  #[inline]
  pub fn add_hash_prev_block(&mut self, hash_prev_block: flatbuffers::WIPOffset<Hash<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Hash>>(CheckpointBeacon::VT_HASH_PREV_BLOCK, hash_prev_block);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CheckpointBeaconBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CheckpointBeaconBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CheckpointBeacon<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CheckpointBeacon::VT_HASH_PREV_BLOCK,"hash_prev_block");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BlockHeaderOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BlockHeader<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockHeader<'a> {
    type Inner = BlockHeader<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BlockHeader<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BlockHeader {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BlockHeaderArgs<'args>) -> flatbuffers::WIPOffset<BlockHeader<'bldr>> {
      let mut builder = BlockHeaderBuilder::new(_fbb);
      if let Some(x) = args.proof { builder.add_proof(x); }
      if let Some(x) = args.hash_merkle_root { builder.add_hash_merkle_root(x); }
      if let Some(x) = args.beacon { builder.add_beacon(x); }
      builder.add_version(args.version);
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_BEACON: flatbuffers::VOffsetT = 6;
    pub const VT_HASH_MERKLE_ROOT: flatbuffers::VOffsetT = 8;
    pub const VT_PROOF: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn version(&self) -> u32 {
    self._tab.get::<u32>(BlockHeader::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn beacon(&self) -> CheckpointBeacon<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<CheckpointBeacon<'a>>>(BlockHeader::VT_BEACON, None).unwrap()
  }
  #[inline]
  pub fn hash_merkle_root(&self) -> Hash<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Hash<'a>>>(BlockHeader::VT_HASH_MERKLE_ROOT, None).unwrap()
  }
  #[inline]
  pub fn proof(&self) -> LeadershipProof<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<LeadershipProof<'a>>>(BlockHeader::VT_PROOF, None).unwrap()
  }
}

pub struct BlockHeaderArgs<'a> {
    pub version: u32,
    pub beacon: Option<flatbuffers::WIPOffset<CheckpointBeacon<'a >>>,
    pub hash_merkle_root: Option<flatbuffers::WIPOffset<Hash<'a >>>,
    pub proof: Option<flatbuffers::WIPOffset<LeadershipProof<'a >>>,
}
impl<'a> Default for BlockHeaderArgs<'a> {
    #[inline]
    fn default() -> Self {
        BlockHeaderArgs {
            version: 0,
            beacon: None, // required field
            hash_merkle_root: None, // required field
            proof: None, // required field
        }
    }
}
pub struct BlockHeaderBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockHeaderBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(BlockHeader::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_beacon(&mut self, beacon: flatbuffers::WIPOffset<CheckpointBeacon<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CheckpointBeacon>>(BlockHeader::VT_BEACON, beacon);
  }
  #[inline]
  pub fn add_hash_merkle_root(&mut self, hash_merkle_root: flatbuffers::WIPOffset<Hash<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Hash>>(BlockHeader::VT_HASH_MERKLE_ROOT, hash_merkle_root);
  }
  #[inline]
  pub fn add_proof(&mut self, proof: flatbuffers::WIPOffset<LeadershipProof<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LeadershipProof>>(BlockHeader::VT_PROOF, proof);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockHeaderBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockHeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BlockHeader<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, BlockHeader::VT_BEACON,"beacon");
    self.fbb_.required(o, BlockHeader::VT_HASH_MERKLE_ROOT,"hash_merkle_root");
    self.fbb_.required(o, BlockHeader::VT_PROOF,"proof");
    flatbuffers::WIPOffset::new(o.value())
  }
}

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
pub enum VersionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Version<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Version<'a> {
    type Inner = Version<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Version<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Version {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args VersionArgs<'args>) -> flatbuffers::WIPOffset<Version<'bldr>> {
      let mut builder = VersionBuilder::new(_fbb);
      builder.add_nonce(args.nonce);
      builder.add_genesis(args.genesis);
      builder.add_capabilities(args.capabilities);
      builder.add_timestamp(args.timestamp);
      builder.add_last_epoch(args.last_epoch);
      if let Some(x) = args.user_agent { builder.add_user_agent(x); }
      if let Some(x) = args.receiver_address { builder.add_receiver_address(x); }
      if let Some(x) = args.sender_address { builder.add_sender_address(x); }
      builder.add_version(args.version);
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 6;
    pub const VT_CAPABILITIES: flatbuffers::VOffsetT = 8;
    pub const VT_SENDER_ADDRESS: flatbuffers::VOffsetT = 10;
    pub const VT_RECEIVER_ADDRESS: flatbuffers::VOffsetT = 12;
    pub const VT_USER_AGENT: flatbuffers::VOffsetT = 14;
    pub const VT_LAST_EPOCH: flatbuffers::VOffsetT = 16;
    pub const VT_GENESIS: flatbuffers::VOffsetT = 18;
    pub const VT_NONCE: flatbuffers::VOffsetT = 20;

  #[inline]
  pub fn version(&self) -> u32 {
    self._tab.get::<u32>(Version::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn timestamp(&self) -> i64 {
    self._tab.get::<i64>(Version::VT_TIMESTAMP, Some(0)).unwrap()
  }
  #[inline]
  pub fn capabilities(&self) -> u64 {
    self._tab.get::<u64>(Version::VT_CAPABILITIES, Some(0)).unwrap()
  }
  #[inline]
  pub fn sender_address(&self) -> Option<Address<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Address<'a>>>(Version::VT_SENDER_ADDRESS, None)
  }
  #[inline]
  pub fn receiver_address(&self) -> Option<Address<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Address<'a>>>(Version::VT_RECEIVER_ADDRESS, None)
  }
  #[inline]
  pub fn user_agent(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Version::VT_USER_AGENT, None).unwrap()
  }
  #[inline]
  pub fn last_epoch(&self) -> u32 {
    self._tab.get::<u32>(Version::VT_LAST_EPOCH, Some(0)).unwrap()
  }
  #[inline]
  pub fn genesis(&self) -> u64 {
    self._tab.get::<u64>(Version::VT_GENESIS, Some(0)).unwrap()
  }
  #[inline]
  pub fn nonce(&self) -> u64 {
    self._tab.get::<u64>(Version::VT_NONCE, Some(0)).unwrap()
  }
}

pub struct VersionArgs<'a> {
    pub version: u32,
    pub timestamp: i64,
    pub capabilities: u64,
    pub sender_address: Option<flatbuffers::WIPOffset<Address<'a >>>,
    pub receiver_address: Option<flatbuffers::WIPOffset<Address<'a >>>,
    pub user_agent: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub last_epoch: u32,
    pub genesis: u64,
    pub nonce: u64,
}
impl<'a> Default for VersionArgs<'a> {
    #[inline]
    fn default() -> Self {
        VersionArgs {
            version: 0,
            timestamp: 0,
            capabilities: 0,
            sender_address: None,
            receiver_address: None,
            user_agent: None, // required field
            last_epoch: 0,
            genesis: 0,
            nonce: 0,
        }
    }
}
pub struct VersionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VersionBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(Version::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: i64) {
    self.fbb_.push_slot::<i64>(Version::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_capabilities(&mut self, capabilities: u64) {
    self.fbb_.push_slot::<u64>(Version::VT_CAPABILITIES, capabilities, 0);
  }
  #[inline]
  pub fn add_sender_address(&mut self, sender_address: flatbuffers::WIPOffset<Address<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Address>>(Version::VT_SENDER_ADDRESS, sender_address);
  }
  #[inline]
  pub fn add_receiver_address(&mut self, receiver_address: flatbuffers::WIPOffset<Address<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Address>>(Version::VT_RECEIVER_ADDRESS, receiver_address);
  }
  #[inline]
  pub fn add_user_agent(&mut self, user_agent: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Version::VT_USER_AGENT, user_agent);
  }
  #[inline]
  pub fn add_last_epoch(&mut self, last_epoch: u32) {
    self.fbb_.push_slot::<u32>(Version::VT_LAST_EPOCH, last_epoch, 0);
  }
  #[inline]
  pub fn add_genesis(&mut self, genesis: u64) {
    self.fbb_.push_slot::<u64>(Version::VT_GENESIS, genesis, 0);
  }
  #[inline]
  pub fn add_nonce(&mut self, nonce: u64) {
    self.fbb_.push_slot::<u64>(Version::VT_NONCE, nonce, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VersionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VersionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Version<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Version::VT_USER_AGENT,"user_agent");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum VerackOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Verack<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Verack<'a> {
    type Inner = Verack<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Verack<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Verack {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args VerackArgs) -> flatbuffers::WIPOffset<Verack<'bldr>> {
      let mut builder = VerackBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct VerackArgs {
}
impl<'a> Default for VerackArgs {
    #[inline]
    fn default() -> Self {
        VerackArgs {
        }
    }
}
pub struct VerackBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VerackBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VerackBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VerackBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Verack<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GetPeersOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GetPeers<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetPeers<'a> {
    type Inner = GetPeers<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GetPeers<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GetPeers {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args GetPeersArgs) -> flatbuffers::WIPOffset<GetPeers<'bldr>> {
      let mut builder = GetPeersBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct GetPeersArgs {
}
impl<'a> Default for GetPeersArgs {
    #[inline]
    fn default() -> Self {
        GetPeersArgs {
        }
    }
}
pub struct GetPeersBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetPeersBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetPeersBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetPeersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetPeers<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PeersOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Peers<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Peers<'a> {
    type Inner = Peers<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Peers<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Peers {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PeersArgs<'args>) -> flatbuffers::WIPOffset<Peers<'bldr>> {
      let mut builder = PeersBuilder::new(_fbb);
      if let Some(x) = args.peers { builder.add_peers(x); }
      builder.finish()
    }

    pub const VT_PEERS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn peers(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Address<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Address<'a>>>>>(Peers::VT_PEERS, None)
  }
}

pub struct PeersArgs<'a> {
    pub peers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Address<'a >>>>>,
}
impl<'a> Default for PeersArgs<'a> {
    #[inline]
    fn default() -> Self {
        PeersArgs {
            peers: None,
        }
    }
}
pub struct PeersBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PeersBuilder<'a, 'b> {
  #[inline]
  pub fn add_peers(&mut self, peers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Address<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Peers::VT_PEERS, peers);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PeersBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PeersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Peers<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PingOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Ping<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Ping<'a> {
    type Inner = Ping<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Ping<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Ping {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PingArgs) -> flatbuffers::WIPOffset<Ping<'bldr>> {
      let mut builder = PingBuilder::new(_fbb);
      builder.add_nonce(args.nonce);
      builder.finish()
    }

    pub const VT_NONCE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn nonce(&self) -> u64 {
    self._tab.get::<u64>(Ping::VT_NONCE, Some(0)).unwrap()
  }
}

pub struct PingArgs {
    pub nonce: u64,
}
impl<'a> Default for PingArgs {
    #[inline]
    fn default() -> Self {
        PingArgs {
            nonce: 0,
        }
    }
}
pub struct PingBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PingBuilder<'a, 'b> {
  #[inline]
  pub fn add_nonce(&mut self, nonce: u64) {
    self.fbb_.push_slot::<u64>(Ping::VT_NONCE, nonce, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PingBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Ping<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PongOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Pong<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Pong<'a> {
    type Inner = Pong<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Pong<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Pong {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PongArgs) -> flatbuffers::WIPOffset<Pong<'bldr>> {
      let mut builder = PongBuilder::new(_fbb);
      builder.add_nonce(args.nonce);
      builder.finish()
    }

    pub const VT_NONCE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn nonce(&self) -> u64 {
    self._tab.get::<u64>(Pong::VT_NONCE, Some(0)).unwrap()
  }
}

pub struct PongArgs {
    pub nonce: u64,
}
impl<'a> Default for PongArgs {
    #[inline]
    fn default() -> Self {
        PongArgs {
            nonce: 0,
        }
    }
}
pub struct PongBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PongBuilder<'a, 'b> {
  #[inline]
  pub fn add_nonce(&mut self, nonce: u64) {
    self.fbb_.push_slot::<u64>(Pong::VT_NONCE, nonce, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PongBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PongBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Pong<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TransactionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Transaction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Transaction<'a> {
    type Inner = Transaction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Transaction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Transaction {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args TransactionArgs) -> flatbuffers::WIPOffset<Transaction<'bldr>> {
      let mut builder = TransactionBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct TransactionArgs {
}
impl<'a> Default for TransactionArgs {
    #[inline]
    fn default() -> Self {
        TransactionArgs {
        }
    }
}
pub struct TransactionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransactionBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransactionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TransactionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Transaction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BlockOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Block<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Block<'a> {
    type Inner = Block<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Block<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Block {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BlockArgs<'args>) -> flatbuffers::WIPOffset<Block<'bldr>> {
      let mut builder = BlockBuilder::new(_fbb);
      if let Some(x) = args.txns { builder.add_txns(x); }
      builder.add_txn_count(args.txn_count);
      if let Some(x) = args.header { builder.add_header(x); }
      builder.finish()
    }

    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_TXN_COUNT: flatbuffers::VOffsetT = 6;
    pub const VT_TXNS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn header(&self) -> BlockHeader<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<BlockHeader<'a>>>(Block::VT_HEADER, None).unwrap()
  }
  #[inline]
  pub fn txn_count(&self) -> u32 {
    self._tab.get::<u32>(Block::VT_TXN_COUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn txns(&self) -> flatbuffers::Vector<flatbuffers::ForwardsUOffset<Transaction<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Transaction<'a>>>>>(Block::VT_TXNS, None).unwrap()
  }
}

pub struct BlockArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<BlockHeader<'a >>>,
    pub txn_count: u32,
    pub txns: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Transaction<'a >>>>>,
}
impl<'a> Default for BlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        BlockArgs {
            header: None, // required field
            txn_count: 0,
            txns: None, // required field
        }
    }
}
pub struct BlockBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<BlockHeader<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BlockHeader>>(Block::VT_HEADER, header);
  }
  #[inline]
  pub fn add_txn_count(&mut self, txn_count: u32) {
    self.fbb_.push_slot::<u32>(Block::VT_TXN_COUNT, txn_count, 0);
  }
  #[inline]
  pub fn add_txns(&mut self, txns: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Transaction<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_TXNS, txns);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Block<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Block::VT_HEADER,"header");
    self.fbb_.required(o, Block::VT_TXNS,"txns");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum InvOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Inv<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Inv<'a> {
    type Inner = Inv<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Inv<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Inv {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InvArgs<'args>) -> flatbuffers::WIPOffset<Inv<'bldr>> {
      let mut builder = InvBuilder::new(_fbb);
      if let Some(x) = args.inventory { builder.add_inventory(x); }
      builder.finish()
    }

    pub const VT_INVENTORY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn inventory(&self) -> flatbuffers::Vector<flatbuffers::ForwardsUOffset<InvVector<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<InvVector<'a>>>>>(Inv::VT_INVENTORY, None).unwrap()
  }
}

pub struct InvArgs<'a> {
    pub inventory: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<InvVector<'a >>>>>,
}
impl<'a> Default for InvArgs<'a> {
    #[inline]
    fn default() -> Self {
        InvArgs {
            inventory: None, // required field
        }
    }
}
pub struct InvBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InvBuilder<'a, 'b> {
  #[inline]
  pub fn add_inventory(&mut self, inventory: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<InvVector<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Inv::VT_INVENTORY, inventory);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InvBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InvBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Inv<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Inv::VT_INVENTORY,"inventory");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GetDataOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GetData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetData<'a> {
    type Inner = GetData<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GetData<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GetData {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GetDataArgs<'args>) -> flatbuffers::WIPOffset<GetData<'bldr>> {
      let mut builder = GetDataBuilder::new(_fbb);
      if let Some(x) = args.inventory { builder.add_inventory(x); }
      builder.finish()
    }

    pub const VT_INVENTORY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn inventory(&self) -> flatbuffers::Vector<flatbuffers::ForwardsUOffset<InvVector<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<InvVector<'a>>>>>(GetData::VT_INVENTORY, None).unwrap()
  }
}

pub struct GetDataArgs<'a> {
    pub inventory: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<InvVector<'a >>>>>,
}
impl<'a> Default for GetDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        GetDataArgs {
            inventory: None, // required field
        }
    }
}
pub struct GetDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_inventory(&mut self, inventory: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<InvVector<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetData::VT_INVENTORY, inventory);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, GetData::VT_INVENTORY,"inventory");
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_message<'a>(buf: &'a [u8]) -> Message<'a> {
  flatbuffers::get_root::<Message<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_message<'a>(buf: &'a [u8]) -> Message<'a> {
  flatbuffers::get_size_prefixed_root::<Message<'a>>(buf)
}

#[inline]
pub fn finish_message_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_message_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Protocol

